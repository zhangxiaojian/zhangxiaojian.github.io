<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>张小贱</title>
    <description>life test</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sun, 14 Jan 2018 18:57:50 +0800</pubDate>
    <lastBuildDate>Sun, 14 Jan 2018 18:57:50 +0800</lastBuildDate>
    <generator>Jekyll v3.7.0</generator>
    
      <item>
        <title>undrop-for-innodb</title>
        <description>&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;undrop-for-innodb 是针对 innodb 的一套数据恢复工具，可以从文件级别恢复诸如：DROP/TRUNCATE table, 删除表中某些记录，innodb 文件被删除，文件系统损坏，磁盘 corruption 等几种情况。本文简单介绍下使用方法和原理浅析。&lt;/p&gt;

&lt;h2 id=&quot;准备&quot;&gt;准备&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git clone https://github.com/twindb/undrop-for-innodb.git 
make
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;需要联合 MySQL 的安装路径编译工具 sys_parser,&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gcc `$basedir/bin/mysql_config --cflags` `$basedir/bin/mysql_config --libs` -o sys_parser sys_parser.c
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;需要的工具都已经完备:
&lt;img src=&quot;http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/9e03cc7bd345bc8842ab88173ce931a6.jpg&quot; alt=&quot;420d94d6-79de-49b3-ad6c-c2648307d1dc.png&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;重要的工具： &lt;code class=&quot;highlighter-rouge&quot;&gt;c_parser &amp;amp;&amp;amp; stream_parser &amp;amp;&amp;amp; sys_parser&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;其中 &lt;code class=&quot;highlighter-rouge&quot;&gt;test.sh &amp;amp;&amp;amp; recover_dictionary.sh &amp;amp;&amp;amp; fetch_data.sh&lt;/code&gt; 是测试的脚本，可以看下里面的逻辑理解工具的用法。&lt;/li&gt;
  &lt;li&gt;三个目录&lt;/li&gt;
  &lt;li&gt;dictionary 里面是模拟 innodb 系统表结构写的 CREATE TABLE 语句，innodb 的系统表对用户不可见，可以在 informatioin_schema 表中找到一些值，但实际上系统表是保存在 ibdata 固定的页上的。&lt;/li&gt;
  &lt;li&gt;sakila 是一些 SQL 语句，用来测试用。&lt;/li&gt;
  &lt;li&gt;include 是从 innodb 拿出来的一些用到的头文件和源文件。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;drop-table&quot;&gt;DROP TABLE&lt;/h2&gt;

&lt;h3 id=&quot;表结构恢复&quot;&gt;表结构恢复&lt;/h3&gt;
&lt;p&gt;一般情况下表结构是存储在 frm 文件中，drop table 会删除 frm 文件，还好我们可以从 innodb 系统表里读取一些信息恢复表结构。innodb 系统表有&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SYS_COLUMNS | SYS_FIELDS | SYS_INDEXES | SYS_TABLES 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;关于系统表结构的具体介绍可以参考 &lt;a href=&quot;https://twindb.com/innodb-dictionary/&quot;&gt;系统表&lt;/a&gt; , 这几个表对于恢复非常重要，下面以一个恢复表结构的例子来说明。&lt;/p&gt;

&lt;p&gt;使用目录 sakila/actor.sql 中的例子：&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`actor`&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;`actor_id`&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;smallint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AUTO_INCREMENT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;`first_name`&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;varchar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;45&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;`last_name`&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;varchar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;45&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;`last_update`&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;timestamp&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;CURRENT_TIMESTAMP&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ON&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;UPDATE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;CURRENT_TIMESTAMP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;PRIMARY&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;KEY&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;`actor_id`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;KEY&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`idx_actor_last_name`&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;`last_name`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ENGINE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;InnoDB&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AUTO_INCREMENT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;201&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CHARSET&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;utf8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;insert&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;into&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;actor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;last_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'zhang'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'jian'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;insert&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;into&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;actor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;last_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'zhan'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'jian'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;insert&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;into&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;actor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;last_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'zha'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'jian'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;insert&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;into&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;actor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;last_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'zh'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'jian'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;insert&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;into&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;actor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;last_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'z'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'jian'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;mysql&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;checksum&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;table&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;actor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;-----------+------------+&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;Table&lt;/span&gt;     &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Checksum&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;-----------+------------+&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;per&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;actor&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2184463059&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;-----------+------------+&lt;/span&gt;
&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;row&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;00&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sec&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;DROP&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;actor&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;需要从系统表中恢复，而系统表是保存在 $datadir/ibdata1 文件中的，使用工具 &lt;code class=&quot;highlighter-rouge&quot;&gt;stream_parser&lt;/code&gt; 解析文件内容。&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$.&lt;/span&gt;/stream_parser &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; /home/zj118228/rds_5616/data/ibdata1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;执行完毕后会在当前目录下生成文件夹 &lt;code class=&quot;highlighter-rouge&quot;&gt;pages-ibdata1&lt;/code&gt; , 目录下按照每个页为一个文件，分为索引页和数据较大的 BLOB 页，我们访问系统表的话，是存在索引页中的。使用另外一个重要的工具 &lt;code class=&quot;highlighter-rouge&quot;&gt;c_parser&lt;/code&gt; 来解析页的内容。&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$.&lt;/span&gt;/c_parser &lt;span class=&quot;nt&quot;&gt;-4Df&lt;/span&gt; pages-ibdata1/FIL_PAGE_INDEX/0000000000000001.page &lt;span class=&quot;nt&quot;&gt;-t&lt;/span&gt; dictionary/SYS_TABLES.sql  | &lt;span class=&quot;nb&quot;&gt;grep&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'sakila/actor'&lt;/span&gt;
000000005927 24000001C809C6 SYS_TABLES &lt;span class=&quot;s2&quot;&gt;&quot;sakila/actor&quot;&lt;/span&gt; 52 4 1 0 80 &lt;span class=&quot;s2&quot;&gt;&quot;&quot;&lt;/span&gt; 38
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;参数解析：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;4 表示文件格式是 REDUNDANT，系统表的格式默认值。另外可以取值 5 表示 COMPACT 格式，6 表示 MySQL 5.6 格式。&lt;/li&gt;
  &lt;li&gt;D 表示只恢复被删除的记录。&lt;/li&gt;
  &lt;li&gt;f 后面跟着文件。&lt;/li&gt;
  &lt;li&gt;t 后面跟着 CREATE TABLE 语句，需要根据表的格式来解析文件。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;得到的结果 ‘SYS_TABLES’ 字段后面的就是系统表 SYS_TABLE 中对应存的记录。 同样的恢复其它三个系统表：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;---&lt;/span&gt; SYS_INDEXES &lt;span class=&quot;s1&quot;&gt;'grep 52'&lt;/span&gt; 是对应 SYS_TABLE 的 TALE ID &lt;span class=&quot;nt&quot;&gt;---&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;/ 
&lt;span class=&quot;nv&quot;&gt;$.&lt;/span&gt;/c_parser &lt;span class=&quot;nt&quot;&gt;-4Df&lt;/span&gt; pages-ibdata1/FIL_PAGE_INDEX/0000000000000003.page &lt;span class=&quot;nt&quot;&gt;-t&lt;/span&gt; dictionary/SYS_INDEXES.sql  | &lt;span class=&quot;nb&quot;&gt;grep&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'52'&lt;/span&gt;
000000005927 24000001C807FF SYS_INDEXES 52 57 &lt;span class=&quot;s2&quot;&gt;&quot;PRIMARY&quot;&lt;/span&gt; 1 3 38 4294967295
000000005927 24000001C80871 SYS_INDEXES 52 58 &lt;span class=&quot;s2&quot;&gt;&quot;idx&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\_&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;actor&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\_&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;last&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\_&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;name&quot;&lt;/span&gt; 1 0 38 4294967295

/&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;---&lt;/span&gt; SYS_COLUMNS &lt;span class=&quot;nt&quot;&gt;---&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;/
./c_parser &lt;span class=&quot;nt&quot;&gt;-4Df&lt;/span&gt; pages-ibdata1/FIL_PAGE_INDEX/0000000000000002.page &lt;span class=&quot;nt&quot;&gt;-t&lt;/span&gt; dictionary/SYS_COLUMNS.sql | &lt;span class=&quot;nb&quot;&gt;grep &lt;/span&gt;52
000000005927 24000001C808F2 SYS_COLUMNS 52 0 &lt;span class=&quot;s2&quot;&gt;&quot;actor&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\_&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;id&quot;&lt;/span&gt; 6 1794 2 0
000000005927 24000001C80927 SYS_COLUMNS 52 1 &lt;span class=&quot;s2&quot;&gt;&quot;first&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\_&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;name&quot;&lt;/span&gt; 12 2162959 135 0
000000005927 24000001C8095C SYS_COLUMNS 52 2 &lt;span class=&quot;s2&quot;&gt;&quot;last&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\_&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;name&quot;&lt;/span&gt; 12 2162959 135 0
000000005927 24000001C80991 SYS_COLUMNS 52 3 &lt;span class=&quot;s2&quot;&gt;&quot;last&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\_&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;update&quot;&lt;/span&gt; 3 525575 4 0

/&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;---&lt;/span&gt; SYS_FIELD  &lt;span class=&quot;s1&quot;&gt;'grep 57\|58'&lt;/span&gt; 对应 SYS_INDEXES 的 ID 列 &lt;span class=&quot;nt&quot;&gt;---&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;/
&lt;span class=&quot;nv&quot;&gt;$.&lt;/span&gt;/c_parser &lt;span class=&quot;nt&quot;&gt;-4Df&lt;/span&gt; pages-ibdata1/FIL_PAGE_INDEX/0000000000000004.page &lt;span class=&quot;nt&quot;&gt;-t&lt;/span&gt; dictionary/SYS_FIELDS.sql | &lt;span class=&quot;nb&quot;&gt;grep&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'57\|58'&lt;/span&gt;
000000005927 24000001C807CA SYS_FIELDS 57 0 &lt;span class=&quot;s2&quot;&gt;&quot;actor&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\_&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;id&quot;&lt;/span&gt;
000000005927 24000001C8083C SYS_FIELDS 58 0 &lt;span class=&quot;s2&quot;&gt;&quot;last&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\_&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;name&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;我们恢复表结构的数据都在这四张系统表中了，SYS_COLUMNS 后面几列的表示 MySQL 内部对于数据类型的编号。&lt;/p&gt;

&lt;p&gt;接下来是恢复阶段&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;使用目录 dictionary 下的四个文件创建四张表（这里数据库名为 recover ）。&lt;/li&gt;
  &lt;li&gt;把上面恢复出来的数据分别导入到对应的表中(注意相同的行去重)。&lt;/li&gt;
  &lt;li&gt;使用工具 sys_parser 恢复 CREATE TABLE 语句。&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sys_parser&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;h&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;127&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;u&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;P&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;56160&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;d&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;recover&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sakila&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;actor&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`actor`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
 &lt;span class=&quot;nv&quot;&gt;`actor_id`&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SMALLINT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;UNSIGNED&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
 &lt;span class=&quot;nv&quot;&gt;`first_name`&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;VARCHAR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;45&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CHARACTER&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;SET&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'utf8'&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;COLLATE&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'utf8_general_ci'&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
 &lt;span class=&quot;nv&quot;&gt;`last_name`&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;VARCHAR&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;45&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CHARACTER&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;SET&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'utf8'&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;COLLATE&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'utf8_general_ci'&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
 &lt;span class=&quot;nv&quot;&gt;`last_update`&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;TIMESTAMP&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;PRIMARY&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;KEY&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;`actor_id`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ENGINE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;InnoDB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;对比发现，恢复出来的 CREATE TABLE 语句相比原来创建的语句信息量有点缺少，因为 innodb 系统表里面存的数据相比 frm 文件是不足的，比如 AUTO_INCREMENT, DECIMAL 类型的精度信息都会缺失，也不会恢复二级索引，外建等。可以看成是表存储结构的恢复。如果有 frm 文件就可以完完整整的恢复了，这篇文章介绍了恢复方法：&lt;a href=&quot;https://twindb.com/how-to-recover-table-structure-from-frm-files-online/&quot;&gt;Get Create Table From frm&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;表数据恢复&quot;&gt;表数据恢复&lt;/h3&gt;

&lt;h4 id=&quot;innodb_file_per_table-off&quot;&gt;innodb_file_per_table off&lt;/h4&gt;
&lt;p&gt;这种情况表中的数据是保存在 ibdata 文件中的，虽然表的数据在数据库中被删除了，但是如果没有被重写，数据还在保存在文件中的，执行下列步骤来恢复：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;使用 stream_parser 分析 ibdata 文件，分别得到每个页的文件。&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;nv&quot;&gt;$.&lt;/span&gt;/stream_parser &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; /home/zj118228/rds_5616/data/ibdata1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ol&gt;
  &lt;li&gt;如表结构分析小节中所示，使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;c_parser&lt;/code&gt; 分析系统表 SYS_TABLES 和 SYS_INDEXES ，根据表名得到 TABLE ID， 根据 TABLE ID 得到 INDEX ID。（INDEX ID 就是上述例子的第 5 列，值为 57 和 58）&lt;/li&gt;
  &lt;li&gt;根据得到的 INDEX ID，到目录 pages-ibdata1 下去找对应的页号，这就是对应的索引表数据所在的数据页。&lt;/li&gt;
  &lt;li&gt;使用 c_parser 读取第 3 步得到的页文件，得到数据。&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$.&lt;/span&gt;/c_parser &lt;span class=&quot;nt&quot;&gt;-6f&lt;/span&gt; pages-ibdata1/FIL_PAGE_INDEX/0000000000000065.page &lt;span class=&quot;nt&quot;&gt;-t&lt;/span&gt; actor.sql
&lt;span class=&quot;nt&quot;&gt;--&lt;/span&gt; Page &lt;span class=&quot;nb&quot;&gt;id&lt;/span&gt;: 579, Format: COMPACT, Records list: Valid, Expected records: &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;5 5&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
000000005D95 E5000001960110 actor 201 &lt;span class=&quot;s2&quot;&gt;&quot;zhang&quot;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;jian&quot;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;2017-11-04 12:30:07&quot;&lt;/span&gt;
000000005D96 E6000001970110 actor 202 &lt;span class=&quot;s2&quot;&gt;&quot;zhan&quot;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;jian&quot;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;2017-11-04 12:30:07&quot;&lt;/span&gt;
000000005D98 E80000019A0110 actor 203 &lt;span class=&quot;s2&quot;&gt;&quot;zha&quot;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;jian&quot;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;2017-11-04 12:30:07&quot;&lt;/span&gt;
000000005D99 E90000019B0110 actor 204 &lt;span class=&quot;s2&quot;&gt;&quot;zh&quot;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;jian&quot;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;2017-11-04 12:30:07&quot;&lt;/span&gt;
000000005DA9 F1000002480110 actor 205 &lt;span class=&quot;s2&quot;&gt;&quot;z&quot;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;jian&quot;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;2017-11-04 12:30:08&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;数据看起来没什么问题，表结构和数据都有了，导进去即可,看一下 checksum 也相同。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mysql&amp;gt; checksum table actor;
+-----------+------------+
| Table     | Checksum   |
+-----------+------------+
| per.actor | 2184463059 |
+-----------+------------+
1 row in set (0.00 sec)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;innodb_file_per_table-on&quot;&gt;innodb_file_per_table on&lt;/h4&gt;
&lt;p&gt;这种情况下表是保存在各自的 ibd 文件中的，当 drop table 之后 ，ibd 文件会被删除，此时最好能够设置磁盘整体只读，避免有其它进程重写文件块。整体的恢复步骤和上一个小节（innodb_file_per_table off） 相同，只是无法从 pages-ibdata1 目录下面找到对应的 page 号。
假设已经完成了前两步，拿到了 INDEX ID。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;stream_parser&lt;/code&gt; 这个工具不但可以读文件，还可以读磁盘，会根据 innodb 数据格式把数据页读出来。为了恢复 68 号数据页，我们执行下面几个步骤：
1.找到被删除的 ibd 文件的挂载磁盘 ／dev/sda5：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$df 
Filesystem           1K-blocks      Used Available Use% Mounted on
/dev/sda2             52327276  47003636   2702200  95% /
tmpfs                 99225896   9741300  89484596  10% /dev/shm
/dev/sda1               258576     55291    190229  23% /boot
/dev/sda5            1350345636 1142208356 208137280  85% /home
/dev/sdb1            3278622264 2277365092 1001257172  70% /disk1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;2.根据 INDEX ID ， 磁盘大小执行 &lt;code class=&quot;highlighter-rouge&quot;&gt;stream_parser&lt;/code&gt;，-t 表示磁盘的大小。&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;nv&quot;&gt;$.&lt;/span&gt;/stream_parser &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; /dev/sda5 &lt;span class=&quot;nt&quot;&gt;-s&lt;/span&gt; 1G &lt;span class=&quot;nt&quot;&gt;-t&lt;/span&gt; 1142G
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;3.在目录 pages—sda5 下找到 68 号页，像上一个小节第 4 步一样恢复数据即可。
4.&lt;划重点&gt; 测试了三次，有两次是恢复不出来的，因为文件很可能被其它进程重写，这取决于文件系统调度还有整体服务器的负载。
5.如果挂载的磁盘上还有其它 mysqld 的数据目录，那么很可能一个 page 文件会很大，监测到其它 ibd 文件的数据，同一个页号的综合在一起，这样辨别出我们需要的数据就比较麻烦。&lt;/划重点&gt;&lt;/p&gt;

&lt;h2 id=&quot;文件页脏写&quot;&gt;文件页脏写&lt;/h2&gt;
&lt;p&gt;MySQL 每次从磁盘读取数据的时候都会进行 checksum 校验，如果校验失败，整个进程就会重启或者退出，校验失败很可能是文件页被脏写了。使用恢复工具直接读取文件很可能可以把未被脏写的行或者页读取出来，损失降到最低。&lt;/p&gt;

&lt;h3 id=&quot;模拟脏写&quot;&gt;模拟脏写&lt;/h3&gt;
&lt;p&gt;同样使用目录 sakila/actor.sql 中的例子，innodb_per_file_table = on：&lt;/p&gt;

&lt;div class=&quot;language-sql highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;CREATE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;TABLE&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`actor`&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;`actor_id`&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;smallint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AUTO_INCREMENT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;`first_name`&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;varchar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;45&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;`last_name`&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;varchar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;45&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;nv&quot;&gt;`last_update`&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;timestamp&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NOT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;CURRENT_TIMESTAMP&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ON&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;UPDATE&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;CURRENT_TIMESTAMP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;PRIMARY&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;KEY&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;`actor_id`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;KEY&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;`idx_actor_last_name`&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;`last_name`&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ENGINE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;InnoDB&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AUTO_INCREMENT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;201&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;DEFAULT&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CHARSET&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;utf8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;insert&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;into&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;actor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;last_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'zhang'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'jian'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;insert&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;into&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;actor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;last_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'zhan'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'jian'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;insert&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;into&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;actor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;last_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'zha'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'jian'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;insert&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;into&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;actor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;last_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'zh'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'jian'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;insert&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;into&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;actor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;last_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;values&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'z'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'jian'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;模拟脏写，打开 actor.ibd 文件, 使用 ‘#’ 覆盖其中一行数据，
&lt;img src=&quot;http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/089813e87cf48f3d435d22a418aaf184.png&quot; alt=&quot;00fdb870-b7df-4122-b7d9-1622bc354737.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从系统表空间确定 INDEX ID （参考 表结构恢复 小节）&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$.&lt;/span&gt;/stream_parser &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; /home/zj118228/rds_5616/data/ibdata1
&lt;span class=&quot;nv&quot;&gt;$.&lt;/span&gt;/stream_parser &lt;span class=&quot;nt&quot;&gt;-f&lt;/span&gt; ~/rds_5616/data/per/actor.ibd
&lt;span class=&quot;nv&quot;&gt;$.&lt;/span&gt;/c_parser &lt;span class=&quot;nt&quot;&gt;-4Df&lt;/span&gt; pages-ibdata1/FIL_PAGE_INDEX/0000000000000001.page &lt;span class=&quot;nt&quot;&gt;-t&lt;/span&gt; dictionary/SYS_TABLES.sql
&lt;span class=&quot;nv&quot;&gt;$.&lt;/span&gt;/c_parser &lt;span class=&quot;nt&quot;&gt;-4Df&lt;/span&gt; pages-ibdata1/FIL_PAGE_INDEX/0000000000000003.page &lt;span class=&quot;nt&quot;&gt;-t&lt;/span&gt; dictionary/SYS_INDEXES.sql
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;INDEX ID 为 76，读取数据：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$./c_parser -6f pages-actor.ibd/FIL_PAGE_INDEX/0000000000000076.page -t sakila/actor.sql
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/be67d98d3e0745dd8991975d30c75e7e.png&quot; alt=&quot;d27b1b03-ac82-4d60-9717-1c58d9587e64.png&quot; /&gt; 
看到有一行数据被 # 号覆盖，然后丢失了一行。&lt;/p&gt;

&lt;p&gt;脏写之后数据库是起不来的，因为 ibd 文件已经损坏了，但此时我们已经拿到了恢复之后的数据，需要把恢复之后的数据导入到数据库里。导入之前删除 actor.ibd 文件，然后启动数据库后执行 &lt;code class=&quot;highlighter-rouge&quot;&gt;drop table actor&lt;/code&gt;, 然后再重新创建表，导入数据即可。如果不小心把 frm 文件也删掉了，是没法 drop table 的，可以在其它数据库里建一个同名，结构相同的表生成 frm 文件，然后拷贝到被删除的目录下，然后再执行 drop table。参考：&lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/innodb-troubleshooting-datadict.html&quot;&gt;Troubleshooting&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;原理浅析&quot;&gt;原理浅析&lt;/h3&gt;

&lt;h4 id=&quot;c_parser&quot;&gt;c_parser&lt;/h4&gt;
&lt;p&gt;恢复工具 &lt;code class=&quot;highlighter-rouge&quot;&gt;c_parser&lt;/code&gt; 其实是按照 innodb 存储数据的格式来分析哪些是我们需要的数据本身，所以页上的数据可以分为两类：1. 用户数据 2. 元数据。而元数据的功能其实并不相同，有些损坏无伤大雅，有些损坏却可能导致整个页无法恢复。这里有几篇介绍&lt;a href=&quot;https://dev.mysql.com/doc/internals/en/innodb-record-structure.html&quot;&gt;Innodb 行记录格式1&lt;/a&gt; and &lt;a href=&quot;http://blog.csdn.net/Linux_ever/article/details/64124868&quot;&gt;Innodb 行记录格式2&lt;/a&gt; ，上一个小节中行记录格式是 Compact，来分析一下为什么会丢了一行数据。&lt;/p&gt;

&lt;p&gt;这是完好的数据页，上面是脏写是把第 12 行数据全部覆盖了，根据 Compact 类型的格式，12 行末尾的 04 03 表示下一行变长数据类型（‘zha’ ‘jian’）的长度倒序，被覆盖之后当然无法解析，于是就丢了一行。那么为什么没有影响后续的行数据呢？第 13 行第 2 列的数据 21 表示下行数据的偏移，幸运的没有被覆盖。如果这个字节被覆盖，那么整个格式就乱了，无法解析。
&lt;img src=&quot;http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/dfe3e6b6bb0a194fec08f4b296464f72.png&quot; alt=&quot;4abe1824-db59-46a4-a610-a24a3cd9bfd0.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;试了其它几种情况：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;第六行第五列 004C 表示 page 的号，破坏之后 stream 出来的页号会变，所以从 Innodb 系统表得到的主键索引页号就不对了。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;infimum&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;supremum&lt;/code&gt; 破坏之后 stream 无法检测出页，所以根本产生不了可恢复的数据。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;stream_parser&quot;&gt;stream_parser&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;c_parser&lt;/code&gt; 是分析页面中用户的行数据，从参数中传入 &lt;code class=&quot;highlighter-rouge&quot;&gt;CREATE TABLE&lt;/code&gt; 语句，根据定义的数据格式逐行解析，得到最终恢复的数据。而 &lt;code class=&quot;highlighter-rouge&quot;&gt;stream_parser&lt;/code&gt; 是分析 ibd／ibdata 文件（或者挂载的磁盘），得到每一个数据页的。根据数据页的元数据，如果满足下列条件，就被认为是一个合法的 Innodb Index 数据页：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;页面最开始前四个字节（checksum）不为 0&lt;/li&gt;
  &lt;li&gt;页面 5-8 字节（页面在 tablespace 中的偏移）不为零，且小于 (ib_size / UNIV_PAGE_SIZE) 最大偏移量，ibd 文件大小除以 Innodb 页大小。&lt;/li&gt;
  &lt;li&gt;在固定偏移处找到 &lt;code class=&quot;highlighter-rouge&quot;&gt;infimum&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;supremum&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考 &lt;code class=&quot;highlighter-rouge&quot;&gt;stream_parser.c&lt;/code&gt; 中的函数 &lt;code class=&quot;highlighter-rouge&quot;&gt;valid_innodb_page&lt;/code&gt;, 关于 Blob page 判定条件略有不同，详细参考 &lt;code class=&quot;highlighter-rouge&quot;&gt;valid_blob_page&lt;/code&gt;，这里以 Index page 为例。&lt;/p&gt;

&lt;p&gt;得到一个合法的页后就以 UNIV_PAGE_SIZE 为大小写入到以 index_id 命名的文件中（也就是 &lt;code class=&quot;highlighter-rouge&quot;&gt;c_parser&lt;/code&gt; 读入的页号判断标准）。&lt;/p&gt;

&lt;h4 id=&quot;页数据格式&quot;&gt;页数据格式&lt;/h4&gt;
&lt;p&gt;这里引用下&lt;a href=&quot;http://hedengcheng.com/?p=118&quot;&gt;登博&lt;/a&gt;画的大图：
&lt;img src=&quot;http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/b1ffab644960e13617606f2cc35d124c.png&quot; alt=&quot;undefined&quot; /&gt;&lt;/p&gt;

&lt;p&gt;根据图中数据格式，如果页面前 8 字节被重写为 0 ，&lt;code class=&quot;highlighter-rouge&quot;&gt;infimum&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;supremum&lt;/code&gt; 被写坏，&lt;code class=&quot;highlighter-rouge&quot;&gt;stream_parser&lt;/code&gt; 无法检测出有效页。如果图中 Page_no 被写坏，那么我们从 Innodb 数据字典中获得的需要解析的文件页号恐怕就不对了，也不知道从那里去恢复。&lt;/p&gt;

&lt;p&gt;所以这种恢复方式是寄托在重要页元数据和行元数据没有被脏写的前提下的，上述分析过后，重要的元数据所占比例较小，如果每个字节被脏写的概率相同，那么数据的可恢复性还是比较可观的。&lt;/p&gt;

&lt;p&gt;最后，对于文件系统损坏或者磁盘 corruption，最重要的把数据拷贝出来，而不是去恢复文件系统或者磁盘，因为上述工具的恢复是基于数据的，参考&lt;a href=&quot;https://twindb.com/take-image-from-corrupted-hard-drive/&quot;&gt;这篇文章&lt;/a&gt;，第一时间使用 dd 命令制作磁盘镜像，再走上述的恢复流程即可。&lt;/p&gt;
</description>
        <pubDate>Sat, 25 Nov 2017 16:19:18 +0800</pubDate>
        <link>http://localhost:4000/computer%20science/mysql/2017/11/25/undrop-for-innodb/</link>
        <guid isPermaLink="true">http://localhost:4000/computer%20science/mysql/2017/11/25/undrop-for-innodb/</guid>
        
        
        <category>computer science</category>
        
        <category>mysql</category>
        
      </item>
    
      <item>
        <title>MySQL 信号处理机制</title>
        <description>&lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;
&lt;p&gt;在 &lt;a href=&quot;https://github.com/alibaba/AliSQL/issues/68&quot;&gt;AliSQL&lt;/a&gt; 上面有人提交了一个 bug，在使用主备的时候  service stop mysql  不能关闭主库，一直显示 shutting down mysql …，到底怎么回事呢，先来看一下  service stop mysql  是怎么停止数据库的。配置 MySQL 在系统启动时启动需要把 MYSQL_BASEDIR/support-files 目录下的脚本 mysql.sever 放到 /etc/init.d/ 目录下，脚本来控制 mysqld 的启动和停止。看一下脚本中的代码 ：&lt;/p&gt;

&lt;div class=&quot;language-perl highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;test&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;$mysqld_pid_file_path&quot;&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;then&lt;/span&gt;
       &lt;span class=&quot;nv&quot;&gt;mysqld_pid&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;sb&quot;&gt;`cat &quot;$mysqld_pid_file_path&quot;`&lt;/span&gt;

       &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;kill&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$mysqld_pid&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;sr&quot;&gt;/dev/&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
       &lt;span class=&quot;k&quot;&gt;then&lt;/span&gt;
         &lt;span class=&quot;nv&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$echo_n&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;Shutting down MySQL&quot;&lt;/span&gt;
         &lt;span class=&quot;nb&quot;&gt;kill&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$mysqld_pid&lt;/span&gt;
         &lt;span class=&quot;c1&quot;&gt;# mysqld should remove the pid file when it exits, so wait for it.&lt;/span&gt;
         &lt;span class=&quot;nv&quot;&gt;wait_for_pid&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;removed&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;$mysqld_pid&quot;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;$mysqld_pid_file_path&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;return_value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;vg&quot;&gt;$?&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
	
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;实际上的关闭动作就是向 mysqld 进程发送一个 kill pid 的信号，也就是 TERM ， wait_for_pid  函数中就是不断检测 $MYSQL_DATADIR 下面的 pid 文件是否存在，并且打印 ‘.’，所以上述问题应该是 mysqld 没有正确处理接收到的信号。&lt;/p&gt;

&lt;h2 id=&quot;信号处理机制&quot;&gt;信号处理机制&lt;/h2&gt;

&lt;h3 id=&quot;多线程信号处理&quot;&gt;多线程信号处理&lt;/h3&gt;
&lt;p&gt;进程中的信号处理是异步的，当信号发送给进程之后，就会中断进程当前的执行流程，跳到注册的对应信号处理函数中，执行完毕后再返回进程的执行流程。在多线程信号处理中，一般采用一个单独的线程阻塞的等待信号集，然后处理信号，重新阻塞等待。线程的信号处理有以下几个特点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;每个线程都有自己的信号屏蔽字（单个线程可以屏蔽某些信号）&lt;/li&gt;
  &lt;li&gt;信号的处理是整个进程中所有线程共享的（某个线程修改信号处理行为后，也会影响其它线程）&lt;/li&gt;
  &lt;li&gt;进程中的信号是递送到单个线程的，如果一个信号和硬件故障相关，那么该信号就会被递送到引起该事件的线程，否是是发送到任意一个线程。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pthread_sigmask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;how&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sigset_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;restrict&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sigset_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;restrict&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;oset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;在进程中使用 sigprocmask 设置信号屏蔽字，在线程中使用 pthread_sigmask，他们的基本相同，pthread_sigmask 工作在线程中，失败时返回错误码，而 sigprocmask 会设置 errno 并返回 -1。参数 how 控制设置屏蔽字的行为，值为 SIG_BLOCK（把信号集添加到现有信号集中，取并集）, SIG_SET_MASK（设置信号集为 set）, SIG_UNBLOCK（从信号集中移除 set 中的信号）。set 表示需要操纵的信号集合。oset 返回设置之前的信号屏蔽字，如果设置 set 为 NULL，可以通过 oset 获得当前的信号屏蔽字。&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sigwait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sigset_t&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;restrict&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;restrict&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sig&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;sigwait 将会挂起调用线程，直到接收到 set 中设置的信号，具体的信号将会通过 sig 返回，同时会从 set 中删除 sig 信号。 在调用 sigwait 之前，必须阻塞那些它正在等待的信号，否则在调用的时间窗口就可能接收到信号。&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pthread_kill&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pthread_t&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;thread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sig&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;发送信号到指定线程，如果 sig 为 0，可以用来判断线程是否还活着。&lt;/p&gt;

&lt;p&gt;man pthread_sigmask 里面给了一个例子：&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pthread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stdio&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stdlib&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unistd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;signal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;errno&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;mi&quot;&gt;7&lt;/span&gt;
  &lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* Simple error handling functions */&lt;/span&gt;
  &lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;
 &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;#&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;define&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;handle_error_en&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;en&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; \
 &lt;span class=&quot;mi&quot;&gt;11&lt;/span&gt;     &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;errno&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;en&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;perror&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EXIT_FAILURE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
 &lt;span class=&quot;mi&quot;&gt;12&lt;/span&gt;
 &lt;span class=&quot;mi&quot;&gt;13&lt;/span&gt;     &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;
 &lt;span class=&quot;mi&quot;&gt;14&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sig_thread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
 &lt;span class=&quot;mi&quot;&gt;15&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;sigset_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sigset_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
 &lt;span class=&quot;mi&quot;&gt;17&lt;/span&gt;     &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sig&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
 &lt;span class=&quot;mi&quot;&gt;18&lt;/span&gt;
 &lt;span class=&quot;mi&quot;&gt;19&lt;/span&gt;     &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(;;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;         &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sigwait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sig&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 &lt;span class=&quot;mi&quot;&gt;21&lt;/span&gt;         &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
 &lt;span class=&quot;mi&quot;&gt;22&lt;/span&gt;             &lt;span class=&quot;n&quot;&gt;handle_error_en&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;sigwait&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 &lt;span class=&quot;mi&quot;&gt;23&lt;/span&gt;         &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Signal handling thread got signal %d&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sig&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 &lt;span class=&quot;mi&quot;&gt;24&lt;/span&gt;     &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
 &lt;span class=&quot;mi&quot;&gt;25&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
 &lt;span class=&quot;mi&quot;&gt;26&lt;/span&gt;
 &lt;span class=&quot;mi&quot;&gt;27&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;argc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;argv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[])&lt;/span&gt;
 &lt;span class=&quot;mi&quot;&gt;28&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;mi&quot;&gt;29&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;pthread_t&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;thread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
 &lt;span class=&quot;mi&quot;&gt;30&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;sigset_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
 &lt;span class=&quot;mi&quot;&gt;31&lt;/span&gt;     &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
 &lt;span class=&quot;mi&quot;&gt;32&lt;/span&gt;     &lt;span class=&quot;cm&quot;&gt;/* Block SIGINT; other threads created by main() will inherit
 33      *               a copy of the signal mask. */&lt;/span&gt;                                                                                                
 &lt;span class=&quot;mi&quot;&gt;32&lt;/span&gt;     &lt;span class=&quot;cm&quot;&gt;/* Block SIGINT; other threads created by main() will inherit
 33      *               a copy of the signal mask. */&lt;/span&gt;
 &lt;span class=&quot;mi&quot;&gt;34&lt;/span&gt;
 &lt;span class=&quot;mi&quot;&gt;35&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;sigemptyset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 &lt;span class=&quot;mi&quot;&gt;36&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;sigaddset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SIGQUIT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 &lt;span class=&quot;mi&quot;&gt;37&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;sigaddset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SIGUSR1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 &lt;span class=&quot;mi&quot;&gt;38&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pthread_sigmask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SIG_BLOCK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 &lt;span class=&quot;mi&quot;&gt;39&lt;/span&gt;     &lt;span class=&quot;c1&quot;&gt;//s = sigprocmask(SIG_BLOCK, &amp;amp;set, NULL);&lt;/span&gt;
 &lt;span class=&quot;mi&quot;&gt;40&lt;/span&gt;     &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
 &lt;span class=&quot;mi&quot;&gt;41&lt;/span&gt;         &lt;span class=&quot;n&quot;&gt;handle_error_en&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;pthread_sigmask&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 &lt;span class=&quot;mi&quot;&gt;42&lt;/span&gt;
 &lt;span class=&quot;mi&quot;&gt;43&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pthread_create&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;kr&quot;&gt;thread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sig_thread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 &lt;span class=&quot;mi&quot;&gt;44&lt;/span&gt;     &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
 &lt;span class=&quot;mi&quot;&gt;45&lt;/span&gt;         &lt;span class=&quot;n&quot;&gt;handle_error_en&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;pthread_create&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 &lt;span class=&quot;mi&quot;&gt;46&lt;/span&gt;
 &lt;span class=&quot;mi&quot;&gt;47&lt;/span&gt;     &lt;span class=&quot;cm&quot;&gt;/* Main thread carries on to create other threads and/or do
 48      *               other work */&lt;/span&gt;
 &lt;span class=&quot;mi&quot;&gt;49&lt;/span&gt;
 &lt;span class=&quot;mi&quot;&gt;50&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;pause&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;            &lt;span class=&quot;cm&quot;&gt;/* Dummy pause so we can test program */&lt;/span&gt;
 &lt;span class=&quot;mi&quot;&gt;51&lt;/span&gt;     &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
 &lt;span class=&quot;mi&quot;&gt;52&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;执行一下：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;./a.out &amp;amp;
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;1] 5423
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;kill&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-QUIT&lt;/span&gt; %1
Signal handling thread got signal 3
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;kill&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-USR1&lt;/span&gt; %1
Signal handling thread got signal 10
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;kill&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-TERM&lt;/span&gt; %1
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;1]+  Terminated              ./a.out
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;测试了一下，把上面代码的 pthread_sigmask 替换成 sigprocmask ，同样能够正确执行，说明线程也能够继承原进程的屏蔽字，不过还是尽量使用 pthread_sigmask, 表述清楚点，而且说不定还有其它坑。&lt;/p&gt;

&lt;h3 id=&quot;mysql-信号处理&quot;&gt;MySQL 信号处理&lt;/h3&gt;
&lt;p&gt;MySQL 是典型的多线程处理，它的信号处理形式和上一小节介绍的差不多，在 mysqld 启动的时候调用 my_init_signal 初始化信号屏蔽字，把需要信号处理线程处理的信号屏蔽起来，然后启动信号处理函数，入口是 signal_hand 。&lt;/p&gt;

&lt;p&gt;在 my_init_signal 函数中，设置 SIGSEGC, SIGABORT, SIGBUS, SIGILL, SIGFPE 的处理函数为 handle_fatal_signal，把 SIGPIPE，SIGQUIT, SIGHUP, SIGTERM, SIGTSTP 加入到信号屏蔽字里，调用 sigprocmask 和 pthread_sigmask 设置屏蔽字。这一系列动作是在 mysql 启动其它辅助线程之前完成的动作，意图很明显，就是让之后的线程都继承设置的信号屏蔽字，把所有的信号交给信号处理线程去处理。&lt;/p&gt;

&lt;p&gt;signal_hand 函数首先把需要处理的信号放到信号集合里去，然后完成 create_pid_file ，data 目录下的 pid 文件实际上是由信号处理线程创建的。接着等待 mysqld 完成启动，各个线程之间需要同步，核心代码是一个死循环，通过 my_sigwait 调用 sigwait 阻塞的等待信号的到来。我们目前主要关心 SIGTERM 的处理，和 SIGQUIT, SIGKILL 处理方式相同，都是调用 kill_server 关闭整个数据库。&lt;/p&gt;

&lt;h2 id=&quot;bug-fix&quot;&gt;Bug Fix&lt;/h2&gt;
&lt;p&gt;文中开头的链接中提到 loose-rpl_semi_sync_master_enabled = 0 关闭就不会有问题， 如果为 1 就会出现无法关闭的情况，顺着这个线索寻找，rpl_semi_sync_master_enabled 在主备使用 semisync 情况下控制启动 Master 节点的 Ack Receiver 线程，初始化阶段的调用堆栈为:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;init_common_variables
		|
		|----- ReplSemiSyncMaster::initObject
						|
						|----- Ack_receiver::start
								
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;而 init_common_variables 的调用是在 my_init_signal 之前，也就是 Ack Receiver 线程没有办法继承信号屏蔽字，不会屏蔽 SIGTERM 信号。在 my_init_signal 中还有一段这样的代码：&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/* Fix signals if blocked by parents (can happen on Mac OS X) */&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;....&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;sa&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sa_handler&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;print_signal_warning&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;sigaction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SIGTERM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sa&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sigaction&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;\&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;对于信号的修改的作用于整个进程的，也就是说之前启动的 Ack Receiver 线程没有信号屏蔽字，而且注册了信号处理函数。当 SIGTERM 发生后，信号处理线程和 Ack Receiver 线程都可以接收信号处理，信号被随机的分发（测试高概率都是发给 Ack Receiver），print_signal_warning 仅仅打印信息到 errlog，就出现了无法关闭 mysqld 的情况了。&lt;/p&gt;

&lt;p&gt;修改也比较简单，把 initObject 的操作放到 my_init_signal 之后就好，注意不能把 init_common_variables 整个移到 my_init_signal 之前，因为 my_init_signal 里面还有要初始化的变量呢。&lt;/p&gt;
</description>
        <pubDate>Mon, 20 Nov 2017 23:57:40 +0800</pubDate>
        <link>http://localhost:4000/computer%20science/database/mysql/2017/11/20/665/</link>
        <guid isPermaLink="true">http://localhost:4000/computer%20science/database/mysql/2017/11/20/665/</guid>
        
        
        <category>computer science</category>
        
        <category>database</category>
        
        <category>mysql</category>
        
      </item>
    
      <item>
        <title>MySQL内存分配机制</title>
        <description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;内存资源由操作系统管理，分配与回收操作可能会执行系统调用（以 malloc 算法为例，较大的内存空间分配接口是 mmap， 而较小的空间 free 之后并不归还给操作系统 ），频繁的系统调用必然会降低系统性能，但是可以最大限度的把使用完毕的内存让给其它进程使用，相反长时间占有内存资源可以减少系统调用次数，但是内存资源不足会导致操作系统频繁换页，降低服务器的整体性能。&lt;/p&gt;

&lt;p&gt;数据库是使用内存的“大户”，合理的内存分配机制就尤为重要，上一期月报介绍了 &lt;a href=&quot;http://mysql.taobao.org/monthly/2017/07/07/&quot;&gt;PostgreSQL 的内存上下文&lt;/a&gt;，本文将介绍在 MySQL 中又是怎么管理内存的。&lt;/p&gt;

&lt;h2 id=&quot;基础接口封装&quot;&gt;基础接口封装&lt;/h2&gt;
&lt;p&gt;MySQL 在基本的内存操作接口上面封装了一层,增加了控制参数 my_flags&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;my_malloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;myf&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;my_flags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;my_realloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;oldpoint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;myf&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;my_flags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;my_free&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;my_flags 的值目前有：&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;MY_FAE&lt;/span&gt; 		&lt;span class=&quot;cm&quot;&gt;/* Fatal if any error */&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;MY_WME&lt;/span&gt;			&lt;span class=&quot;cm&quot;&gt;/* Write message on error */&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;MY_ZEROFILL&lt;/span&gt;	&lt;span class=&quot;cm&quot;&gt;/* Fill array with zero */&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;MY_FAE 表示内存分配失败就退出整个进程，MY_WME 表示内存分配失败是否需要记录到日志中，MY_ZEROFILL 表示分配内存后初始化为0。&lt;/p&gt;

&lt;h2 id=&quot;mem_root&quot;&gt;MEM_ROOT&lt;/h2&gt;

&lt;h3 id=&quot;基本结构&quot;&gt;基本结构&lt;/h3&gt;
&lt;p&gt;在 MySQL 的 Server 层中广泛使用 MEM_ROOT 结构来管理内存，避免频繁调用封装的基础接口，也可以统一分配和管理，防止发生内存泄漏。不同的 MEM_ROOT 之间互相没有影响，不像 PG 中不同的内存上下文之间还有关联。这可能得益于 MySQL Server 层是面向对象的代码，MEM_ROOT 作为类中的一个成员变量，伴随着对象的整个生命周期。比较典型的类有： THD，String, TABLE, TABLE_SHARE, Query_arena, st_transactions 等。&lt;/p&gt;

&lt;p&gt;MEM_ROOT 分配内存的单元是 Block，使用 USED_MEM 结构体来描述。结构比较简单，Block 之间相互连接形成内存块链表，left 和 size 表示对应 Block 还有多少可分配的空间和总的空间大小。&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;st_used_mem&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;				   &lt;span class=&quot;cm&quot;&gt;/* struct for once_alloc (block) */&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;st_used_mem&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;	   &lt;span class=&quot;cm&quot;&gt;/* Next block in use */&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;		   &lt;span class=&quot;cm&quot;&gt;/* memory left in block  */&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;		   &lt;span class=&quot;cm&quot;&gt;/* size of block */&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;USED_MEM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;而 MEM_ROOT 结构体负责管理 Block 链表 ：&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;st_mem_root&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;USED_MEM&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;free&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;                  &lt;span class=&quot;cm&quot;&gt;/* blocks with free memory in it */&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;USED_MEM&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;used&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;                  &lt;span class=&quot;cm&quot;&gt;/* blocks almost without free memory */&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;USED_MEM&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pre_alloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;             &lt;span class=&quot;cm&quot;&gt;/* preallocated block */&lt;/span&gt;
  &lt;span class=&quot;cm&quot;&gt;/* if block have less memory it will be put in 'used' list */&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;min_malloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;block_size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;               &lt;span class=&quot;cm&quot;&gt;/* initial block size */&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;block_num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;          &lt;span class=&quot;cm&quot;&gt;/* allocated blocks counter */&lt;/span&gt;
  &lt;span class=&quot;cm&quot;&gt;/* 
     first free block in queue test counter (if it exceed 
     MAX_BLOCK_USAGE_BEFORE_DROP block will be dropped in 'used' list)
  */&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;first_block_usage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;error_handler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MEM_ROOT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;整体结构就是两个 Block 链表，free 链表管理所有的仍然存在可分配空间的 Block，used 链表管理已经没有可分配空间的所有 Block。pre_alloc 类似于 PG 内存上下文中的 keeper，在初始化 MEM_ROOT 的时候就可以预分配一个 Block 放到 free 链表中，当 free 整个 MEM_ROOT 的时候可以通过参数控制，选择保留 pre_alloc 指向的 Block。min_malloc 控制一个 Block 剩余空间还有多少的时候从 free 链表移除，加入到 used 链表中。block_size 表示初始化 Block 的大小。block_num 表示 MEM_ROOT 管理的 Block 数量。first_block_usage 表示 free 链表中第一个 Block 不满足申请空间大小的次数，是一个调优的参数。err_handler 是错误处理函数。&lt;/p&gt;

&lt;h3 id=&quot;分配流程&quot;&gt;分配流程&lt;/h3&gt;
&lt;p&gt;使用 MEM_ROOT 首先需要初始化，调用 init_alloc_root, 通过参数可以控制初始化的 Block 大小和 pre_alloc_size 的大小。其中比较有意思的点是 min_block_size 直接指定一个值 32，个人觉得不太灵活，对于小内存的申请可能会有比较大的内存碎片。另一个是 block_num 初始化为 4，这个和决定新分配的 Block 大小策略有关。&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;init_alloc_root&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MEM_ROOT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mem_root&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;block_size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                     &lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pre_alloc_size&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__attribute__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unused&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;mem_root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;free&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mem_root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;used&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mem_root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pre_alloc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;mem_root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;min_malloc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;mem_root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;block_size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;block_size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ALLOC_ROOT_MIN_BLOCK_SIZE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;mem_root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;error_handler&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;mem_root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;block_num&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;                       &lt;span class=&quot;cm&quot;&gt;/* We shift this with &amp;gt;&amp;gt;2 */&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;mem_root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first_block_usage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pre_alloc_size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mem_root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;free&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mem_root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pre_alloc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;
         &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;USED_MEM&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;my_malloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pre_alloc_size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ALIGN_SIZE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;USED_MEM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)),&lt;/span&gt;
                               &lt;span class=&quot;n&quot;&gt;MYF&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))))&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;mem_root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;free&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pre_alloc_size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ALIGN_SIZE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;USED_MEM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;mem_root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;free&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pre_alloc_size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;mem_root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;free&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;rds_update_query_size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mem_root&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mem_root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;free&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;DBUG_VOID_RETURN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;初始化完成就可以调用 alloc_root 进行内存申请，整个分配流程并不复杂，代码也不算长，为了方便阅读贴出来，也可以略过直接看分析。&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;alloc_root&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MEM_ROOT&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mem_root&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;get_size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;block_size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;uchar&lt;/span&gt;        &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;point&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;reg1&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;USED_MEM&lt;/span&gt;    &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;reg2&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;USED_MEM&lt;/span&gt;    &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ALIGN_SIZE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mem_root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;free&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 判断 free 链表是否为空&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
             &lt;span class=&quot;n&quot;&gt;mem_root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first_block_usage&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ALLOC_MAX_BLOCK_USAGE_BEFORE_DROP&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
             &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ALLOC_MAX_BLOCK_TO_DROP&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 优化策略&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;                &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt;                &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* Remove block from list */&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;            &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mem_root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;used&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;mem_root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;used&lt;/span&gt;            &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;mem_root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first_block_usage&lt;/span&gt;    &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// 找到一个空闲空间大于申请内存空间的 Block &lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// free 链表为空，或者没有满足可分配条件 Block&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;       &lt;span class=&quot;cm&quot;&gt;/* Time to alloc new block */&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;block_size&lt;/span&gt;    &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mem_root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;block_size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mem_root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;block_num&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;get_size&lt;/span&gt;    &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ALIGN_SIZE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;USED_MEM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;get_size&lt;/span&gt;    &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MY_MAX&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get_size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;block_size&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;USED_MEM&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;my_malloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get_size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MYF&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MY_WME&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ME_FATALERROR&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mem_root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;error_handler&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mem_root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;error_handler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)();&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;DBUG_RETURN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;                              &lt;span class=&quot;cm&quot;&gt;/* purecov: inspected */&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;mem_root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;block_num&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;    &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;    &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get_size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;    &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get_size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ALIGN_SIZE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;USED_MEM&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;    
        &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt;        &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;// 新申请的 Block 放到 free 链表尾部&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;point&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;uchar&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mem_root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;min_malloc&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// 分配完毕后，Block 是否还能在 free 链表中继续分配&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;                                                                       &lt;span class=&quot;cm&quot;&gt;/* Full block */&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt;                &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;                   &lt;span class=&quot;cm&quot;&gt;/* Remove block from list */&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;            &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mem_root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;used&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;mem_root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;used&lt;/span&gt;            &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;mem_root&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first_block_usage&lt;/span&gt;    &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;首先判断 free 链表是否为空，如果不为空，按逻辑应该遍历整个链表，找到一个空闲空间足够大的 Block，但是看代码是先执行了一个判断语句，这其实是一个空间换时间的优化策略，因为free 链表大多数情况下都是不为空的，几乎每次分配都需要从 free 链表的第一个 Block 开始判断，我们当然希望第一个 Block 可以立刻满足要求，不需要再扫描 free 链表，所以根据调用端的申请趋势，设置两个变量：ALLOC_MAX_BLOCK_USAGE_BEFORE_DROP 和 ALLOC_MAX_BLOCK_TO_DROP，当 free 链表的第一个 Block 申请次数超过 ALLOC_MAX_BLOCK_USAGE_BEFORE_DROP 而且剩余的空闲空间小于 ALLOC_MAX_BLOCK_TO_DROP，就把这个 Block 放到 used 链表里，因为它已经一段时间无法满足调用端的需求了。&lt;/p&gt;

&lt;p&gt;如果在 free 链表中没有找到合适的 Block，就需要调用基础接口申请一块新的内存空间，新的内存空间大小当然至少要满足这次申请的大小，同时预估的新 Block 大小是 : &lt;code class=&quot;highlighter-rouge&quot;&gt;mem_root-&amp;gt;block_size * (mem_root-&amp;gt;block_num &amp;gt;&amp;gt; 2)&lt;/code&gt; 也就是初始化的 Block 大小乘以当前 Block 数量的 1/4，所以初始化 MEM_ROOT 的 block_num 至少是 4。&lt;/p&gt;

&lt;p&gt;找到合适的 Block 之后定位到可用空间的位置就行了，返回之前最后需要判断 Block 分配之后是否需要移动到 used 链表。&lt;/p&gt;

&lt;p&gt;归还内存空间的接口有两个：&lt;code class=&quot;highlighter-rouge&quot;&gt;mark_blocks_free(MEM_ROOT *root)&lt;/code&gt;和 &lt;code class=&quot;highlighter-rouge&quot;&gt;free_root(MEN_ROOT *root，myf MyFlags)&lt;/code&gt; ，可以看到两个函数的参数不像基础封装的接口，没有直接传需要归还空间的指针，传入的是 MEM_ROOT 结构体指针，说明对于 MEM_ROOT 分配的内存空间，是统一归还的。&lt;code class=&quot;highlighter-rouge&quot;&gt;mark_blocks_free&lt;/code&gt; 不真正的归还 Block，而是放到 free 链表中标记可用。&lt;code class=&quot;highlighter-rouge&quot;&gt;free_root&lt;/code&gt; 真正归还空间给操作系统，MyFlages 可以控制是否和标记删除的函数行为一样，也可以控制 pre_alloc 指向的 Block 是否归还。&lt;/p&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;从空间利用率上来讲，MEM_ROOT 的内存管理方式在每个 Block 上连续分配，内部碎片基本在每个 Block 的尾部，由 min_malloc 成员变量和参数 ALLOC_MAX_BLOCK_USAGE_BEFORE_DROP，ALLOC_MAX_BLOCK_TO_DROP 共同决定和控制，但是 min_malloc 的值是在代码中写死的，有点不够灵活，可以考虑写成可配置的，同时如果写超过申请长度的空间，就很有可能会覆盖后面的数据，比较危险。但相比 PG 的内存上下文，空间利用率肯定是会高很多的。&lt;/li&gt;
  &lt;li&gt;从时间利用率上来讲，不提供 free 一个 Block 的操作，基本上一整个 MEM_ROOT 使用完毕才会全部归还给操作系统，可见 MySQL 在内存上面还是比较“贪婪”的。
*&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 22 Aug 2017 18:08:35 +0800</pubDate>
        <link>http://localhost:4000/database/mysql/2017/08/22/mysql-e5-86-85-e5-ad-98-e5-88-86-e9-85-8d-e6-9c-ba-e5-88-b6/</link>
        <guid isPermaLink="true">http://localhost:4000/database/mysql/2017/08/22/mysql-e5-86-85-e5-ad-98-e5-88-86-e9-85-8d-e6-9c-ba-e5-88-b6/</guid>
        
        <category>Database</category>
        
        <category>mysql</category>
        
        <category>设计原则</category>
        
        <category>面向对象</category>
        
        
        <category>database</category>
        
        <category>mysql</category>
        
      </item>
    
      <item>
        <title>到底谁奇怪</title>
        <description>&lt;h3 id=&quot;奇怪的大叔&quot;&gt;奇怪的大叔&lt;/h3&gt;

&lt;p&gt;我是黄山本地人，今年四十多岁了，上有老下有小的，我书读的不多，年轻的时候还可以靠出点力，现在真是有力都没地方使，黄山这几年主要是发展旅游业，其它行业不太景气，前几年我们一帮伙计发现了商机，因为黄山汽车站和火车站离景区还是有一段距离的，没有直达的公交车，的士根本就不够用！现在的游客都是比较有钱才出来逛的，宁可多花点钱，也不想耽误太多时间在路上。于是我们一帮人开始用自己的私家车拉客，不说旺季了，即使是淡季，游客也是络绎不绝的，大伙对收入都比较满意。可是我没有私家车啊，眼看着他们找到了一条致富之路，却只有眼红的份。家里没有太多积蓄，女儿正在外地读书，想当年我们这帮人一起打工的时候，我可是他们的老大，凡事都听我指挥，现在真有一种虎落平阳的感觉。&lt;/p&gt;

&lt;p&gt;不过没多久我就找到了一个突破口，这帮小子为了争客人竟然反目，还打起来了，然后警察局，旅游管理局什么的都知道了我们的黑车，他们警告我们再出现这种事就不让我们拉游客了。我心里清楚，我们送更多的游客，提供方便的交通，最终收益的是他们，不会轻易不让我们干的。但是我们不能再自己人和自己人过不去了，为了解决内部矛盾，我们一块成立了黄山地区的专车联盟，各自有各自的区域，司机负责开车，“中介”负责把游客从车站带到车里，按比例拿一部分回扣。我没有私家车，但是可以做中介啊！再怎么说以前混的也不错，汽车西站这个点基本被我承包了，为了避免抢客，我们定下了行规，是谁先抢到游客就是谁的，别人绝对不能动。&lt;/p&gt;

&lt;p&gt;喜迎G20，为了让杭州的市民在G20期间别呆在杭州，黄山景区那几天对杭州市民免费开放。大几百的门票肯定会吸引不少游客，但是羊毛出在羊身上，景区内的管不了，不过我们这几天的价格也比平时高了好几倍！汽车西站真是一块福地，客流量比其它地方都大，看来选择坐汽车的多于坐火车的，不对，应该是没抢到票！一共有五天的开放时间，前三天主要是流入，从车站到景区车费不过30，我们拿20%的回扣，其实一单也没有多少。重头都在最后两天嘞！火车票早就已经售光，汽车票也没有了，只剩下黑大巴车，从黄山直接开到杭州。正常90的票价，现在至少要150，因为大巴坐不满他们跑一趟损失太大，我们的回扣也可以拿到30%，真是丰收的时候啊。&lt;/p&gt;

&lt;p&gt;今天是返程的高峰，人流量特别大，我早早就来了，一单接一单真是不亦乐乎，这片都是我们的人，价钱没得商量，反正不坐就回不去，出来逛的都不在乎这几十块钱。中午的时候，我盯上了四个年轻人，两男两女，看着就是要返程的样子，他们先是到车站旁边的饭馆吃饭，我就跟着他们，一坐下我就出击了。&lt;/p&gt;

&lt;p&gt;“是要去杭州吗？”&lt;/p&gt;

&lt;p&gt;“是啊” 其中一个瘦瘦高高的男生说。&lt;/p&gt;

&lt;p&gt;“走啊，我们有车马上就走，今天车站没车了，人有多，我们刚好有几个座位，我给你们留着啊“ 其实车多的很，给他们点压力，快点送上车，准备下一个目标。&lt;/p&gt;

&lt;p&gt;”我们先不急，中午都还没吃饭，先吃饭再说“&lt;/p&gt;

&lt;p&gt;”那你们赶紧吃啊，座位给你们留好了，吃完就走。 你们是点菜还是盖饭？“ 我擦，赶紧的，千万别点菜，这要等到什么时候。&lt;/p&gt;

&lt;p&gt;”点菜“&lt;/p&gt;

&lt;p&gt;”好，那你们快去点，座位留好了，放心，快吃啊。“ 赶快吃！！&lt;/p&gt;

&lt;p&gt;中午这会好像突然人一下少了，应该都是在吃午饭，我就在这等着这一单吧，四个人，也有小200块。过了20分钟，我看他们吃的差不多了，就过去喊他们走。另一个男生表示要先去车站里看一下，确认下有没有票。没关系啊，早就没有了，随便看。在车站口等他们的时候，我看见有其中一个女生走在后面，有一个不认识的人在旁边搭讪，不是我们组织的人。他们从车站出来发现确实没有票，走在后面的女生和他们一块商量了一下，说是要再看看！我这火一下就上来了，等了这么长时间，肯定是刚才不认识的那个人说了什么。规矩就是规矩，是谁抢到的游客就是谁的，别人绝对不能动。&lt;/p&gt;

&lt;p&gt;他们出站往刚才过来的方向走，我就在后面跟着，看谁敢和我抢。走几步就发现刚才那个人走到他们旁边，”120一个人，现在就走“。妈的，这一片都是150，给老子玩这套。我在后面指着他大骂一声”你哪里的，懂不懂规矩，找事是吧“。那个人一看我跟过来，我料他也不敢惹我，这可是老子的地盘。果然，他就怂了，丢下四个年轻人走一边去了。我的人就是我的人，谁也抢不走！&lt;/p&gt;

&lt;p&gt;我走到他们跟前，说”快走吧，刚才吃饭时候都说好了，座位都给你们留着，这些人便宜一点，不一定能给你们拉到杭州“ 看来需要威逼一下了。&lt;/p&gt;

&lt;p&gt;”大叔，刚说了我们要再看一下，这边便宜一点，你别跟着我们。“&lt;/p&gt;

&lt;p&gt;”我怎么跟着你们了，刚才都说好了，现在都是这个价钱“ 我他妈真生气了，等了半个小时。嗓门也是大起来了。&lt;/p&gt;

&lt;p&gt;”我们再看看行吧，我们想坐哪个车是自由“&lt;/p&gt;

&lt;p&gt;四个年轻人就往边上走，我这会火气真的上来了，我就要跟着他们，看这个车站哪个敢和我抢人。走几步就有几个我们的人和他们搭讪，还没等他们回答，我就大喝一声，看我脾气也就乖乖走开了了。我今天在这，就必须从我这上车，走到哪我就跟到哪。&lt;/p&gt;

&lt;p&gt;他们一看没办法，就顺着路往更远的地方走，看来是想甩开我，没门！差不多出了车站的范围，他们看我还跟着，我就上前去再说”这片都是我们的人，我们有我们行规，别人不能再拉你们。大不了给你们120，赶紧走“ 心想着别耗着了，少赚点没事，下午单子还多，别浪费了时间。&lt;/p&gt;

&lt;p&gt;”大叔，这现在不是钱不钱的问题，你别跟着我们，我们想坐什么车就坐什么车，你这样跟着我们是什么意思，今天我们不走了“。&lt;/p&gt;

&lt;p&gt;”我怎么不跟着你们呢，我就看看谁敢拉你们走“  这是我定的行规。&lt;/p&gt;

&lt;p&gt;”再说一遍，别跟着我们。“&lt;/p&gt;

&lt;p&gt;他们说完就往另一个方向走，我就不信他们今天不走了。不过眼看下午客流量大起来了，得想想办法。我就喊了另一个我们的伙计，刚开着车送完客人回来，我让他过去假装另一个中介，再去问问这几个年轻人。我就在旁边等着，过一会伙计回来说他们还是不走，我真的是怒了，再次走到他们跟前理论&lt;/p&gt;

&lt;p&gt;”我们有我们的规矩，今天没人敢拉你们“&lt;/p&gt;

&lt;p&gt;”我们也有自己的自由，想坐谁的车就坐谁的车，你再跟着我们，就报警了“&lt;/p&gt;

&lt;p&gt;报警？我啥都没干，这是我们的规矩啊。我打算走了，不能再浪费时间 。&lt;/p&gt;

&lt;p&gt;”我告诉你们几个年轻人啊，你们不要这么奇怪！“&lt;/p&gt;

&lt;h3 id=&quot;奇怪的年轻人&quot;&gt;奇怪的年轻人&lt;/h3&gt;

&lt;p&gt;我是一名计算机专业的研究生，暑假来杭州实习，两个月过的非常开心，能呆在理想的公司理想的部门，还有业界有名的大神带，不仅能学到东西，还有比学校高不知道多少倍的工资，不过学校已经开学，过不了多久就要撤了。&lt;/p&gt;

&lt;p&gt;喜迎G20，整个杭州放5天假，我们也不例外。得知放假消息，就有小伙伴计划出去玩，黄山景区不要门票，凑够一行四人，愉快决定。车票紧张，只买到了去的，返程票还没买到。坐大巴从杭州到黄山西站，晚上吃点当地特色，买点登山用的拐杖等，其中有一个臭鳜鱼，不像臭豆腐，那是真的臭，强烈不建议……  第二天中午开始登山，因为听卖拐杖的阿姨说，早上排队的人太多，就算早上去，也会排队到中午的。缆车上去，开始爬，背着帐篷和行李，感觉不要太酸爽。不过看见了美丽的日出和日落，非常值的。下山之后去了宏村，和之前去过的周庄，凤凰，乌镇等等真有点不一样，这里有很多学画画的学生就在旁边写生，还有其它院校的研究生过来考察，准备写毕业论文（别人这么早就开始准备了，我小论文还没发，还在玩！内心收到了谴责…..）此处应该放图，舒缓受谴责的心情。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/img/uploads/2016/11/h1.jpg&quot;&gt;&lt;img src=&quot;/img/uploads/2016/11/h1.jpg&quot; alt=&quot;h1&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/img/uploads/2016/11/h2.jpg&quot;&gt;&lt;img src=&quot;/img/uploads/2016/11/h2.jpg&quot; alt=&quot;h2&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/img/uploads/2016/11/h3.jpg&quot;&gt;&lt;img src=&quot;/img/uploads/2016/11/h3.jpg&quot; alt=&quot;h3&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/img/uploads/2016/11/h4.jpg&quot;&gt;&lt;img src=&quot;/img/uploads/2016/11/h4.jpg&quot; alt=&quot;h4&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/img/uploads/2016/11/h6.jpg&quot;&gt;&lt;img src=&quot;/img/uploads/2016/11/h6.jpg&quot; alt=&quot;h6&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/img/uploads/2016/11/h7.jpg&quot;&gt;&lt;img src=&quot;/img/uploads/2016/11/h7.jpg&quot; alt=&quot;h7&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;逛完宏村就打算返程了，找了一个黑车从景区到汽车西站，路上的司机大叔看我们还没有买到票，就一路上要帮我们找拼车，200一个人，七座车直接到杭州。我们比较犹豫，因为不知道汽车站是什么行情，而且中午饭还没吃，考虑了一下还是拒绝了大叔，打算先去汽车站把中午饭搞定，然后用滴滴看看能不能约到顺风车。到了汽车西站找了来的时候光顾过的饭馆，刚刚坐下就有一个看着五大三粗的中年大叔过来。&lt;/p&gt;

&lt;p&gt;“是要去杭州吗？”&lt;/p&gt;

&lt;p&gt;“是啊” 先看看这边什么行情再说。&lt;/p&gt;

&lt;p&gt;“走啊，我们有车马上就走，今天车站没车了，人有多，我们刚好有几个座位，我给你们留着啊“&lt;/p&gt;

&lt;p&gt;”我们先不急，中午都还没吃饭，先吃饭再说“ 我们还要再看看，说不定车站还有车，顺风车好像也联系到了，正在等师傅的回应。&lt;/p&gt;

&lt;p&gt;”那你们赶紧吃啊，座位给你们留好了，吃完就走。 你们是点菜还是盖饭？“&lt;/p&gt;

&lt;p&gt;”点菜“  这大叔真是… 一看就像让我们吃了盖饭赶紧走，就要点菜吃，不用管我们了。。。&lt;/p&gt;

&lt;p&gt;”好，那你们快去点，座位留好了，放心，快吃啊。“&lt;/p&gt;

&lt;p&gt;大叔走了，我们也没有再留意他，毕竟这种人在所有车站都有。不紧不慢的吃完旅游最后一餐，滴滴师傅没有回应，打算一会先去车站里面看看有没有退票的，没有的话就在车站看一下，找个靠谱的黑车回去。&lt;/p&gt;

&lt;p&gt;刚刚起身，那个五大三粗的大叔就过来了，招呼我们往车站方向走。我们表示要先去车站看一下，大叔就跟着我们在车站门口等着。xx同学爬完山已经走不动了，就落在了后面，我们出来之后她说刚才有个人说他有回杭州的顺丰车，刚好可以坐四个人，每人120，对比起来这个要划算的多，而且是私家车的话不用等，说不定可以拉到杭州里面，刚才的黑车大巴好像只能到老余杭，对比起来确实实惠的多。大叔马上就凑过来了，说要我们快上车，座位已经留好。我们就告诉他别急，我们再看一下。大叔看着就有点不太高兴，我们没在意，就往刚才来的方向走。有一个30岁左右的小伙向我们走过来。&lt;/p&gt;

&lt;p&gt;“120一个人，现在就走”。&lt;/p&gt;

&lt;p&gt;我们刚准备详细问问拉到哪下，刚才的大叔就在后面大喊一声 “你哪里的，懂不懂规矩，找事是吧”。那个架势，好像分分钟就要打起来了，小伙看着不像本地人，也不想惹事，就示意抱歉然后走开了。大叔又走过来说：&lt;/p&gt;

&lt;p&gt;“快走吧，刚才吃饭时候都说好了，座位都给你们留着，这些人便宜一点，不一定能给你们拉到杭州“&lt;/p&gt;

&lt;p&gt;”大叔，刚说了我们要再看一下，这边便宜一点，你别跟着我们。“ 我们火气也上来了，想坐谁的车是我们的自由，大叔老跟着我们什么意思！两个女生看到这么个粗野的大叔也有点怕，更是不可能坐他的车走了，一看就不像好人。&lt;/p&gt;

&lt;p&gt;”我怎么跟着你们了，刚才都说好了，现在都是这个价钱“&lt;/p&gt;

&lt;p&gt;”我们再看看行吧，我们想坐哪个车是自由“ 这大叔真是地头蛇，刚才哪里就说好了，绝对不是什么好人，不能上他的车。&lt;/p&gt;

&lt;p&gt;我们就往车站更远的地方走，心想先甩掉他，然后再看看其他的中介，价钱无所谓，起码人看着要讲理吧。没走几步就有一个人过来搭讪，问我们是不是去杭州，还没回答，又是那个粗野的大叔在后面大喝一声，他们好像认识，那个人就识趣的离开了。卧槽，这大叔是这一片的恶霸吧，好像没有人敢惹他的样子。我们确实有点怕这个大叔了，在这人生地不熟的，遇到这么个地头蛇，真不知道他接下来能干出什么事！大叔又上来说：&lt;/p&gt;

&lt;p&gt;”这片都是我们的人，我们有我们行规，别人不能再拉你们。大不了给你们120，赶紧走“&lt;/p&gt;

&lt;p&gt;”大叔，这现在不是钱不钱的问题，你别跟着我们，我们想坐什么车就坐什么车，你这样跟着我们是什么意思，今天我们不走了“。我真是火气上来了，管你什么地头蛇，遇到这种人，你越是好好说话，他越是觉着你好欺负。&lt;/p&gt;

&lt;p&gt;”我怎么不跟着你们呢，我就看看谁敢拉你们走“&lt;/p&gt;

&lt;p&gt;”再说一遍，别跟着我们。“ 我的嗓门也大起来了。&lt;/p&gt;

&lt;p&gt;我们想着这大叔一直跟着我们不是办法，就往车站旁边的一条路走，打算先找一个咖啡店或者茶秀坐一会，反正他一直在也没有人敢拉我们走。边走边回头看，真怕大叔再跟来，拐了个弯看不到他了，放心了一点。这时候有个开着车的年轻人又过来搭讪，问我们走不走。我们不傻啊，这一片都是一伙的人，就算有人想偷偷把我们拉走，万一让那个大叔看见，再互相打起来怎么办，于是拒绝了。大叔立刻从拐角就出来了！&lt;/p&gt;

&lt;p&gt;”我们有我们的规矩，今天没人敢拉你们“&lt;/p&gt;

&lt;p&gt;”我们也有自己的自由，想坐谁的车就坐谁的车，你再跟着我们，就报警了“ 到了这种程度，我都已经做好了肉搏的准备，虽然瘦很多，不过毕竟年轻，打起来胜负难说。&lt;/p&gt;

&lt;p&gt;”我告诉你们几个年轻人啊，你们不要这么奇怪！”  说完大叔就上了刚才来搭讪的年轻人的车。卧槽，原来是陷阱，想想就觉得后怕，要是上了车，说不定被拉到哪里去了！&lt;/p&gt;

&lt;p&gt;眼看大叔走了，松了一口气，打算放弃西站这个点，坐公交去了不远的火车站，心想这没有火车应该也有类似这里的黑车，赶紧离开这个是非之地才好。刚到火车站就有人问我们走不走，经历了刚才的胁迫，只想赶紧上车，不要再看到那个大叔。过来两辆小摩托，拉我们去大巴的位置。走着走着我们就感觉不对劲，这不是往刚才西站的方向吗！！遇到刚才的大叔怎么办！！越走心越虚，不过下车已经来不及了，还好在到达西站前到了大巴车，虚惊一场。&lt;/p&gt;

&lt;p&gt;坐下之后我们算是放心了，大家都在说，“我们坐哪个车难道不是我们的自由吗，大叔还说我们奇怪，他才真是奇怪！”&lt;/p&gt;

&lt;h3 id=&quot;后记&quot;&gt;后记&lt;/h3&gt;

&lt;p&gt;文章第一部分人物背景纯属虚构，第二部分亲身经历。其实在整个过程中我并没有觉得大叔怀有恶意，从小身边有很多这样的人，他们可能文化程度不高，做事有些偏激，但是并不是坏人，只是容易冲动。可能在他眼里我们确实是怪人，就像我们无法理解他的行为一样。脑补了另一个角色，只是想表达善恶，好坏有时候都过于主观，保护好自己，坚持自己的观念是没有错，不过尽量不以恶意揣测别人即可。&lt;/p&gt;
</description>
        <pubDate>Wed, 09 Nov 2016 11:41:18 +0800</pubDate>
        <link>http://localhost:4000/life%20traces/2016/11/09/e5-88-b0-e5-ba-95-e8-b0-81-e5-a5-87-e6-80-aa/</link>
        <guid isPermaLink="true">http://localhost:4000/life%20traces/2016/11/09/e5-88-b0-e5-ba-95-e8-b0-81-e5-a5-87-e6-80-aa/</guid>
        
        
        <category>life traces</category>
        
      </item>
    
      <item>
        <title>我的25年</title>
        <description>&lt;p&gt;前段时间看了大神P叔的博客，除了技术之外，看得出对自己人生清晰的规划，结合P叔现在的成就，可以说当年吹的牛逼都实现了，并且有过之而无不及。其中有一篇 &lt;strong&gt;&lt;a href=&quot;http://www.penglixun.com/life/diary/my_20_years.html&quot;&gt;我的20年&lt;/a&gt;&lt;/strong&gt; ，四岁就知道自己想上国防科大，真是让四岁还不知道要上哪所小学的我羡慕不已。今天刚刚好走过25年的人生，也来总结一下~&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1991/09/20&lt;/strong&gt; （农历八月十三）下午3：15 张小贱闪亮登场，刚出生貌似五斤二两，注定从一开始就是个瘦子。&lt;/p&gt;

&lt;p&gt;1992 1岁 ，最先学会的运动是爬，而且不会往前爬，只会往后爬，有大人逗我的话，只能是越逗越远。大概是一岁零三个月的时候学会走路，现在觉得学会走路是特别有纪念意义的事，高中的时候才能正式开启“职业生涯”。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1993 ~ 1995&lt;/strong&gt; **2岁到4岁 **那时候我是大人眼中的“家娃”，基本上不怎么出去，就在家里玩一些小玩具，把所有的玩具分成两派，左手拿一个，右手拿一个，然后让他们打来打去，我还记得有一个类似奥特曼的，他就是我这里的英雄，各种打架总是他赢。 这时候年幼无知，不知道怎么回事，特别喜欢穿裙子。。我到现在也无法理解。。还有一件事，以前家里厨房过来有一道帘子，妈妈做好饭往里面端，我往外面跑，隔着门帘撞到了她怀里，热腾腾的稀饭浇了我一脸，基本上是毁容了，后来有一个亲戚在药店上班，拿了什么特效药，不过嘱咐我千万不能用手碰，也不能出去见风。还好小时候比较听话，乖乖呆在家里，后来恢复的还行。不过总是觉得是因为这碗稀饭，才导致现在只能靠才华吃饭。。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1996&lt;/strong&gt; &lt;strong&gt;5岁&lt;/strong&gt; 到了上幼儿园的年纪，不过“家娃”属性太重，第一天被送到的时候我看着这么多小孩，还有不认识的老师，哭着喊着不要呆，最后妈妈还是心一软把我带回去了，所以没有上过幼儿园。回去之后要准备上学前班，要我在家自己练自己的名字，怎么说上学要会写名字吧。不过快开学的时候才发现我练错了，，练的是健康的“健”，户口本上的是刀剑的”剑“，因为小时候身体不好，就想健康点，后来派出所报名字是姥爷去的，我和我姐的名字都惨遭报错。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1997&lt;/strong&gt; &lt;strong&gt;6岁&lt;/strong&gt; 学前班，终于开始了我长达二十年的求学生涯。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1998&lt;/strong&gt; &lt;strong&gt;7岁&lt;/strong&gt; 一年级，性格慢慢开朗起来，开始变成大人口中的”野“娃，不像现在的高楼小区，当时住在一个大院子里，认识了好多玩伴。每天放学就在院子里玩各种游戏，一直到下午吃饭的时候就能听到家长们在呼唤自己孩子的名字回去吃饭，而我们听到以后就躲起来等他们到其它地方去找。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1999&lt;/strong&gt; &lt;strong&gt;8岁&lt;/strong&gt; 二年级，这年还是有点印象，因为一首来吧来吧，相约98。还因为另一件事，感冒发烧去打吊针，结果分给一个实习护士，手脚扎满然后在头上扎，一共11针，终于大功告成。不知道她是否还记得当年一个小朋友让她的扎针技术突飞猛进。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2000&lt;/strong&gt; &lt;strong&gt;9岁&lt;/strong&gt; 三年级，都说可以跨世纪了，真的是千载难逢，我还是继续着无忧无虑的生活，和小伙伴们玩着市面上流行的东西。弹子（玻璃球），画片，烟盒，啤酒瓶的盖子，四驱车，悠悠球，沙包，皮筋，铁环等等。爬高上低，在大院子的每个角落探险，大院子里有很多小孩，自然跟着几个稍大点的分成小群体，当时最流行的两句话就是：我不和你玩了。小心我告你妈。我在里面算稍大的一批，也有点号召力，最关键的是，上面说的那些玩的东西，几乎没有人可以与我匹敌，经常玩一下午把别人赢光，然后再买给他，用它家里冰箱的一根巧乐滋来交换。&lt;/p&gt;

&lt;p&gt;2001 10岁 四年级，清楚的记得换了班主任，还从主教学楼搬到了新教学楼的一层。这时候出现了游戏机，插卡的那种。大家也都开始玩。经过我长时间的申请，并且当时的游戏机还叫学习机，里面内置的游戏可以联系打字和英语，家里人看到有益学习，终于让我的手。然后就开始购置游戏卡，100 合 1 ，300 合 1，不过最好玩的游戏永远是 4 合 1，7 合 1。价钱也贵很多，好像当时就要20一盘。为了资源充分利用，全院子的小伙伴就开始互相交换着玩，我还记得把我最喜欢的热血4合1给换出去了，他再也没有还给我。。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2002&lt;/strong&gt; &lt;strong&gt;11岁&lt;/strong&gt; 五年级，学校开设了电脑课程，我还清楚的记得机房后面贴着几个大字 ” 电脑要从娃娃抓起“。第一堂课教开关机，开机要先开主机再开显示器，关机要先关显示器再关主机。我并没有像很多计算机大神前辈一样，从此开启了一发不可收拾的计算机之路。当时根本买不起家用pc，上课也是练打字，做ppt，扫雷，纸牌，听歌。 不过开始了几年一发不可收拾的书法之路，当时作业的字写得特别丑，每次班主任都会点名批评，说”字和狗爬的一样“，一次和妈妈逛街，路过少年宫，看到有书法培训班，我俩都以为是钢笔字，就果断报名了，去上课才发现是毛笔书法，不过老师说这样才能练出来字，就开始练字了~&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2003&lt;/strong&gt; &lt;strong&gt;12岁&lt;/strong&gt; 六年级，经过一段时间的练习，字确实好看了很多，也疯狂的喜欢上了练字，一没事就写，在学校上课没有装备就用中性笔在书上按照毛笔的写法练，这个习惯保持了好多年。开始班上集体是练”颜“体字的，就是颜真卿的字，后来我去书店看字帖的时候发现了”欧“体字，欧阳询的字，像是发现了新大陆，感觉字体特别清秀，看着就忍不住想要临摹。上课的时候就趁老师不注意偷偷拿自己的字帖写，被老师发现了好几次，叫我练颜体。但是根本忍不住啊，老师可能发现这个孩子对欧体是真爱，就特别同意我练欧体字。现在也要感谢老师的开明，才让我保持了多年的兴趣。顺利的考过了书法六级。六年级还有一件重要事，因为院子比我高一两级的孩子英语成绩都惨不忍睹，尤其是我姐，从他们口中得知，英语单词真是难记，初中课程也难的多，一不留神就落在后面听不懂了。因为有了前车之鉴，妈妈就给我报名了英语辅导班，遇到了Anna 老师，学习了后面特别受用的音标，记单词就快的多，后面跟着老师学习了新概念英语 1 ，2。初中高中英语一直都还不错。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2004&lt;/strong&gt; &lt;strong&gt;13岁  &lt;/strong&gt;初一，换了一所学校，换了一个新家，一群新的同学。课程比小学紧了不少，起码要开始上晚自习了，练字时间就渐渐少了。另一个原因是迷上了打乒乓球，中学乒乓球气氛很好，有十二个质量不错的球桌。每天放学最后一节课提前五分钟收拾好书包，铃一响就冲下去，晚了就没位置了。周六周日，一有时间就去打球，技术也好了很多，也开始看乒乓球比赛，知道了马琳，王励勤，王皓（现在的马龙张继科都是当时的不起眼的小弟），疯狂的喜欢这乒乓球，就像之前疯狂的喜欢书法一样。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2005&lt;/strong&gt; &lt;strong&gt;14岁&lt;/strong&gt; 初二，加了两门课，物理和化学。学习属性开始慢慢出现了，物理第一次月考之后连续好几次都是满分，数学化学也差不多，慢慢班里前几，尝到了好处，比如去打乒乓球班主任再也不会说先把成绩搞上去。。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2006&lt;/strong&gt; &lt;strong&gt;15岁&lt;/strong&gt; 初三，开始意识到要上一个好的高中，中考前几个月通过了西安铁一中的考试，中考差不多都会要。可是铜川的中考成绩普遍低于西安成绩，去西铁一中要交好多钱的择校费。就留在了本地读高中。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2007&lt;/strong&gt; &lt;strong&gt;16岁&lt;/strong&gt; 高一，因为中考成绩好，报名晚了几天，找到了副校长办公室，免了军训，还让他把初中玩的好的几个人分到一个班。。高一成绩还行，打酱油参加数学竞赛，竟然过了，当时数列都还没有学，然后和一群高二的去参加比赛，没得什么奖。。不过文理分科的时候是第一名，记得这么清楚是因为以后的学号都是01，每次考试都要坐第一排，真是不爽。不过这都不重要，因为高一正式开始了我的“职业生涯”，学校有一个土操场，体育课我们借个足球摆两个门就开始踢，所过之处尘土飞扬，寸草不生。初中听妈妈的话坚决不去网吧，会“学坏”，高中网吧盛行，忍不住去了。和几个踢球的同学一块开始玩实况足球 8，包夜的话能玩一晚上不停。班上有不少开始被我们带着踢实况足球的最后都忍不住开始了在操场上踢真正的足球，可见所谓的玩游戏都是坏处，是不对的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2008&lt;/strong&gt; &lt;strong&gt;17岁&lt;/strong&gt; 高二，各种竞赛都报名了，数理化生，比较可惜的是所在小城市没有普及信息竞赛，要不可以早几年开始编程。其它竞赛学校的态度也是随便参加一下，当时带班的数学老师就说了，虽然是竞赛培训，但也不能为了几个苗苗讲的太深。。物理竞赛书上的很多题，老师自己都不会，还是我牺牲了坐公交思考人生的时间思考物理想明白的。。真是和大城市不能比，，从来没有学生是打算靠竞赛进入大学的。后来得了几个三等奖，学校奖励了100，老师奖励2500。我也是百思不得解。不过土球场装上了塑胶，一个正规的6人足球场比什么奖都来的开心。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2009&lt;/strong&gt; &lt;strong&gt;18岁&lt;/strong&gt; 高三，开始一轮一轮的复习，差不多一半的考试可以第一，不过对于未来要去哪个学校，学什么专业，都没有太大的方向。一次月考结束，分给了学校几个西交大自主招生的考试名额，什么都没准备，就去试了下。老师带着我们去西安，找了个30一晚比较皮夹气的住宿，睡的特别不舒服，一直到凌晨三点都没有睡着。第二天六点就起来考试了，而且是一天连考六门，中午不带休息。所以基本上是懵逼的，我还记得一哥们在我旁边直接睡着了，打呼噜。。结果自然失败，不过决定高考就考西交大吧，离家近，学校又不错。在周围邻居里面吹个牛逼还是够的。高考发挥一般，考试的时候我竟然在几道大题没有做的情况下，脑子里开始想足球比赛的画面。。分数出来高重点线小50分，报西交大是没戏了，于是填了两个省内两个省外，随波逐流。专业也是两个大类，当时比较火爆的土木建筑类，还有就是计算机类。现在想来，真是万幸，几乎是踩着线进的合并没多久中南，进的成立没多久的软件学院。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2010&lt;/strong&gt; &lt;strong&gt;19岁&lt;/strong&gt; 大一，幸运的被分到1008班，720寝室。大一比较懵懂，高中的时候受很多大学生回来吹牛的影响，认为大学真的只要及格就好，自由，自由，自由，可能真的对刚刚高考完的我们很有杀伤力。那时候我只想锻炼好身体，正好遇到了同样喜欢踢球的室友，我们三个报名参加四人比赛拿了亚军，还一起加了信息学院足球队，因为软件学院刚刚独立，没有球队。经常下午踢完球书不带就去上课。我还加了乒乓球协会，混了一个部长。。至今想不明白怎么选上的。。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2011&lt;/strong&gt; &lt;strong&gt;20岁&lt;/strong&gt; 大二，从新校区搬到了铁道校区，开始有公司来给我们实训，这时候才正式开始认识写代码这件事。做一个局域文件传输系统，我负责写消息传输这块，抱着c++的书，跑通了两台机器的文件发送和接收，别提多高兴了。这学期专业课也开始多了，经过大一的惨痛教训，开始认真上课，自习，考试，写代码（主要是课程设计）。成绩突飞猛进，排在年级第五，拿了一万多的奖学金，感觉有钱无比。。踢球也有重要收获，我们班经过惨烈的三场淘汰赛，拿到了冠军，那张我们一起跳起来的照片值得一生珍藏。除了班里，我们也开始和大三的学长一起组建软件学院足球队，不过这一年非常坎坷，有很多的矛盾，也是到处输球，不过现在想起来，是我们以后在场上场下变得互相信任不可获缺的一部分。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2012&lt;/strong&gt; &lt;strong&gt;21岁&lt;/strong&gt; 大三，选了嵌入式的方向，经过几次课设，实训，接触了Java开发，嵌入式系统，Linux c/C++ 开发。还和小伙伴组队学安卓，暑假搞了个软件参加谷歌应用大赛，赚了个背包。这个阶段对计算越来越有兴趣，能写出来东西，最好是能运行的界面，当时就觉得很有成就感了。后来大三下学期需要找暑期实习，开始投简历，面试。初出茅庐，不知道行业深浅。被腾讯挂了，阿里电话面试java被问的世界观都碎了。还好后来过了三家+华为，就选择在华为实习。面试期间多次想过考研，研友都找好了，暑假自习室都租好了！不过后来我和研友发现都可以保研，又都找到实习了，就果断转让自习位置。&lt;strong&gt;&lt;a href=&quot;http://www.zhangxiaojian.name/%E5%87%BF%E4%B8%80%E5%8F%A3%E6%B7%B1%E4%BA%95/&quot;&gt;这篇文章&lt;/a&gt;&lt;/strong&gt;说了在华为实习后为什么选择保研。另一件事：这一年我们球队开始越来越团结，一起成立的软件学院足球队，备战队史首次参加的校级比赛。每天下午一起训练，一起踢野球，踢完球去洗澡然后到后街吃饭，约其它院的友谊赛。和去年不同，我们已经很少输了！第一次参加校级比赛，就小组第一出线，从开始被最不看好，到最后虐爆传统强队，创造了历史，也结下了深刻的友谊。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2013&lt;/strong&gt; &lt;strong&gt;22岁&lt;/strong&gt;， 大四，实习拒绝转正后，开始变得索然无味，确定保研之后就结束了实习，早早来到了实验室。此时已经决定了以后发展的方向——数据库。不得不说，受到了&lt;strong&gt;&lt;a href=&quot;http://hedengcheng.com/&quot;&gt;登博&lt;/a&gt;&lt;/strong&gt; 的影响，那时登博还在网易，我是参加网易宣讲第一次见到登博，关注了他的微博，由此认识了阿里系，网易系的数据库大牛们，听说了阿里云，听说了RDS。在实验室接触了Berkeley DB，用它当存储引擎实现实验室自己的数据库。下学期回到学校，和最珍贵的大学生活，1008班，720寝室，软件学院足球队告别。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2014&lt;/strong&gt; &lt;strong&gt;23岁&lt;/strong&gt;，研一，最重要的事就是选了&lt;strong&gt;&lt;a href=&quot;http://totemdb.whu.edu.cn/personal/ywpeng/index_cn.html&quot;&gt;彭老师&lt;/a&gt;&lt;/strong&gt; 的课《PostgreSQL 数据库内核分析》，实验室数据库开发过程中遇到的难题，在PG中都能找到很好的解决方式和思路。看着PG几乎完美的代码，和彭老师精彩的课堂讲解，对PG产生了很大兴趣，开始自己试着看一块，改改里面的东西，偷点拿出来放到实验室的数据库里用。后来在校园里碰到彭老师踢完球回来，原来都是足球爱好者，彭老师拉我进院里老师的足球队，晚上有野球也带我去玩。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2015&lt;/strong&gt; &lt;strong&gt;24岁&lt;/strong&gt;，研二，开始从头开发分布式数据库，实验室单机数据库因为逻辑复杂出现瓶颈，学了不少分布式的东西，用了几个月时间搭出来一个可以用的版本。因为彭老师的关照，接触到了PG界的大神&lt;strong&gt;&lt;a href=&quot;http://blog.163.com/digoal@126/&quot;&gt;德哥&lt;/a&gt;&lt;/strong&gt; ，在众多大神面前做了内核的分享。还接触到了现在的老大&lt;strong&gt;&lt;a href=&quot;http://weibo.com/tdingqi?refer_flag=1005055013_&amp;amp;is_all=1&quot;&gt;奇哥&lt;/a&gt;&lt;/strong&gt;，时间比较短，只是匆匆聊了几句，留了电话。因为早就确定了未来的工作是阿里的数据库部门（这点和P叔一样，说明阿里数据库团队叼了很多年啊，哈哈），今年的实习就忍不住投了，经过了至今最变态的面试后，见到了从登博开始知道的所有数据库大神，实习两个月拿到了正式的offer，虽然从PG转到了MySQL，不过就像明虚师兄说的一样，未来全栈，不应该是一个数据库领域的专家。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2016&lt;/strong&gt; &lt;strong&gt;25岁&lt;/strong&gt;，回到学校没有几天，最后一年的学生生涯，最后一年足球“职业生涯”&lt;/p&gt;

&lt;p&gt;过去是读书的20年，未来是为理想和生活奋斗的20年，加油。&lt;/p&gt;

</description>
        <pubDate>Tue, 13 Sep 2016 20:51:58 +0800</pubDate>
        <link>http://localhost:4000/life%20traces/2016/09/13/my_25_years/</link>
        <guid isPermaLink="true">http://localhost:4000/life%20traces/2016/09/13/my_25_years/</guid>
        
        
        <category>life traces</category>
        
      </item>
    
      <item>
        <title>Berkeley DB 锁子系统的配置</title>
        <description>&lt;p&gt;最近小伙伴在分布式数据库（DPINM）环境下做实验，数据集比较大，分到集群中每台机器上，会报lock不够用的错。Berkeley DB在初始化的时候，就会初始化锁子系统，为锁结构分配内存空间，一旦启动，是不可以动态分配的，如果不够用，就会报错。后来调节了参数，加大了Locks,  Lockers, Locked Object 的最大数量，重启之后被惊呆了，锁子系统映射到文件系统的共享内存空间竟然有60多G，磁盘立马就不够用了（挂载目录只有100G….）。以前看到过配置锁子系统的参数该如何算，总结起来就是能大就大，毕竟不够用重启很麻烦，但万万没想到占这么大的空间，所以还是仔细看看怎么配置比较合理的好。&lt;/p&gt;

&lt;h2 id=&quot;概念介绍&quot;&gt; 概念介绍&lt;/h2&gt;

&lt;p&gt;首先要知道BDB中的Locker, Lock, Lock Object 是什么含义：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Locker： 持有锁的对象。如果在支持事务的情况下，就表示事务句柄（DbTxn），如果在不支持事务的情况下，就表示游标或者DB 句柄。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Lock：表示锁的数据结构，在数据库中，锁就代表了被锁的对象。因为一般获取一个互斥对象之前要获取锁，如果不能获得，就表示对象被锁住了。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Locked Object：真正想要锁住的对象，一般指的是数据库页，在数据库配置成Queue 类型的时候表示一条记录（k-v）。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;估算方法&quot;&gt;估算方法&lt;/h2&gt;

&lt;p&gt;不支持事务的配置相对简单，这里介绍支持事务的 Berkeley DB Transactional Data Store。最推荐的算法是实践，让系统在负载比较极端的情况下运行，然后使用db_stat 命令去查看锁子系统的统计信息，来决定配置的数量，然后把这些数量double，基本上就够用了。但是极端这个情况不好说，所以也提供了自己估算的方法：&lt;/p&gt;

&lt;h4 id=&quot;1-估算locker&quot;&gt;1 估算Locker&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;如果使用了事务特性，Locker 的数量可以估算为系统最大同时打开的非事务游标数，打开的数据库句柄数，还有此时活动的事务数和子事务数之和。对于子事务数的估算应该到子事务的提交，而不是父事务的提交。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果没有使用事务特性，可以估算为系统最大同时打开的非事务游标数，打开的数据库句柄中非游标操作的数量（数据库句柄可以直接存取数据，也可以使用游标存取，如果不打开游标就计算数据库句柄数，否则计算游标数）。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;2-估算lock-object&quot;&gt;2 估算Lock Object&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;每次访问 non-Queue 数据库的时候，每一个数据页（默认8k）需要一个Lock Object&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;对于Queue 数据库，每一条记录（k-v）都需要一个Lock Object。在删除记录的时候不断使用 DB_NEXT 或者 DB_PREV 获得下一条，上一条记录时，不需要额外进行计算。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;对于 Btree 或 Recno 类型的数据库，在更新操作导致树分裂，需要分裂阶段额外的Lock Object。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;对于Hash 和 Queue 数据库，每一次访问都需要在 metadata page（元数据页）上加锁，但不会一直持续到事务结束。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果事务执行了更新操作，导致需要alloc 一个新页，那么需要在 metadata page 上加锁，直到事务结束。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;需要注意的是，在事务的生命周期内，总是不断的积累申请到的Lock，但是需要的Lock Object 数量就是这个事务周期内所有操作所需要的数量，也就是说如果对一个数据页（或者Queue的记录），即使多次访问，也只需要一个Lock Object。举个例子：一个事务总共需要访问10调记录，那么就需要10个Lock Object，如果有同时有10个并发的访问线程，就需要配置系统拥有100个Lock Object（因为每个线程都有一个事务）。关于Lock Object 数量多配置一点没关系，因为它的结构占用空间比较小。&lt;/p&gt;

&lt;h4 id=&quot;3-估算-lock&quot;&gt;3 估算 Lock&lt;/h4&gt;

&lt;p&gt;Lock的数量不太容易估算，可以使用公式：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Lock = 2 * (Locker) * (Lock Object) * 2&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;最后乘的2表示对每个object的读写两种加锁模式。这是比较坏的情况下估算出来的值。一般用不到这么多。&lt;/p&gt;

&lt;h3 id=&quot;4-锁表分区&quot;&gt; 4 锁表分区&lt;/h3&gt;

&lt;p&gt;对锁表进行分区可以充分利用多核CPU，调用函数 DB_ENV-&amp;gt;set_lk_partitions() 完成。每一个分区都可以独立的被一个线程访问，更多的分区意味着更高的并发。默认是在环境启动的时候配置成 cpu 数量的十倍。对于单cpu系统，单个分区反而会比多个分区更有效率。分区之后，最好将Object 和 Lock 分配到各个分区中，便于并发获取。如果其中一个分区用完了Lock 或 Lock Object 资源，会从其它分区中请求，但是频繁的请求会降低效率。&lt;/p&gt;

&lt;p&gt;参考：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://docs.oracle.com/cd/E17076_04/html/programmer_reference/lock_max.html&quot;&gt;http://docs.oracle.com/cd/E17076_04/html/programmer_reference/lock_max.html&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 31 Mar 2016 22:18:11 +0800</pubDate>
        <link>http://localhost:4000/berkeley%20db/computer%20science/database/2016/03/31/berkeley-db-e9-94-81-e5-ad-90-e7-b3-bb-e7-bb-9f-e7-9a-84-e9-85-8d-e7-bd-ae/</link>
        <guid isPermaLink="true">http://localhost:4000/berkeley%20db/computer%20science/database/2016/03/31/berkeley-db-e9-94-81-e5-ad-90-e7-b3-bb-e7-bb-9f-e7-9a-84-e9-85-8d-e7-bd-ae/</guid>
        
        <category>Berkeley DB</category>
        
        <category>Database</category>
        
        
        <category>Berkeley DB</category>
        
        <category>computer science</category>
        
        <category>database</category>
        
      </item>
    
      <item>
        <title>Berkeley DB 事务支持的应用架构</title>
        <description>&lt;p&gt;本文翻译自Berkeley DB 官方文档 &lt;a href=&quot;http://docs.oracle.com/cd/E17076_04/html/programmer_reference/transapp_app.html&quot;&gt;&lt;strong&gt;Architecting Transactional Data Store applications&lt;/strong&gt;&lt;/a&gt; 一节，主要讲述使用BDB作为存储引擎时提供事务支持的几种进程访问模式。每个BDB环境都对应一个文件系统目录，其中包涵存储的数据和运行时提供的锁资源，互斥变量资源，共享缓冲池等。每个目录可以被多个BDB进程打开访问，但使用复杂度有较大区别。需要说明的是，每一个目录在打开它的BDB进程中被称作一个数据库环境，一个目录可以对应多个环境，一个环境只能对应打开一个目录。几种架构模式分别为：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;一个进程&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;多个相关的进程&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;多个不相关的进程&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;正文&quot;&gt;正文：&lt;/h3&gt;

&lt;p&gt;当构建支持事务的应用程序，在架构方面就需要考虑应用程序的启动（是否需要执行recover动作），还要考虑如何处理系统或应用程序的错误。关于如何执行recover，请参看 &lt;a href=&quot;http://docs.oracle.com/cd/E17076_04/html/programmer_reference/transapp_recovery.html&quot;&gt;&lt;strong&gt;Recovery procedures&lt;/strong&gt;&lt;/a&gt; 一节。&lt;/p&gt;

&lt;p&gt;数据库环境恢复（&lt;a href=&quot;http://docs.oracle.com/cd/E17076_04/html/programmer_reference/transapp_recovery.html&quot;&gt;&lt;strong&gt;Recovery&lt;/strong&gt;&lt;/a&gt;）是一个单控制线程的处理过程，也就是说，一个线程必须在其它任何线程访问数据库环境之前完成恢复动作。（注：几个线程打开的是相同的目录）&lt;/p&gt;

&lt;p&gt;执行恢复首先会标记已存在的数据库环境为“失败”，然后删除它，这会导致任何正在访问这个环境的的控制线程失败，并返回到应用程序处理（注：任何调用BDB函数访问数据库的操作都会失败，如果应用程序没有处理失败的代码，整个进程都会退出）。这个特点使应用程序进行恢复时不用考虑还可能有其它的线程在访问已经被删除的环境。重新创建数据库环境的顺序是序列化的，因此多线程/进程试图创建数据库环境将会序列化的跟在一个创建线程之后。&lt;/p&gt;

&lt;p&gt;另一个方面，当删除（当做是恢复的其中一步）一个数据库环境时，需要考虑其它正在访问环境的线程使用的mutex变量类型。假如当数据库环境失败的时候，正在使用test-and-set mutexs 类型互斥变量，其它正在等待互斥变量的控制线程就会在环境被标记为“失败”的时候立刻检测到，然后在 BDB API 调用中返回一个错。如果环境失败的时候使用 blocking mutexs 互斥变量，并且底层系统实现互斥变量并不会因为占有互斥变量的控制线程死亡而解锁 mutex waiter，那么当环境恢复的时候等待mutex的线程将会永远阻塞。如果应用程序阻塞在其它事件上（比如等待一个socket 网络连接或者一个 GUI 事件），可能一段时间内都无法检测环境的恢复（注：因为此时并没有调用任何BDB的API）。这种mutex实现的操作系统并不多，但是存在的；构建在这种操作系统的应用程序在架构的时候，需要执行&lt;a href=&quot;http://docs.oracle.com/cd/E17076_04/html/programmer_reference/transapp_recovery.html&quot;&gt;&lt;strong&gt;recovery&lt;/strong&gt;&lt;/a&gt; 的线程能够显示的中断正在使用相同环境的的进程，或者配置BDB使用 test-and-set mutexs，或者实现一些超时控制，看门狗进程用来唤醒或杀死一直在阻塞的线程。&lt;/p&gt;

&lt;p&gt;即便如此，对于多个控制线程试图同时恢复一个数据库环境还是没有多大意义，因为最后一个执行的还是会删除所有之前控制线程创建的环境。然而，对于一些应用程序，首先在启动多个进程， 使用一个控制线程来执行&lt;a href=&quot;http://docs.oracle.com/cd/E17076_04/html/programmer_reference/transapp_recovery.html&quot;&gt;&lt;strong&gt;recovery&lt;/strong&gt;&lt;/a&gt;，然后其它进程打开环境继续执行，这样做是有意义的。&lt;/p&gt;

&lt;p&gt;有三种常规的方式去构建一个BDB事务支持的应用程序。选择哪种主要基于应用程序是由单个进程组成或由多个相关的进程组成（例如，当系统启动时打开一个server），还是由多个不相关的进程组成（例如，由网络连接或用户打开的进程，记录到系统当中）。&lt;/p&gt;

&lt;h3 id=&quot;1-单进程&quot;&gt;1 单进程&lt;/h3&gt;

&lt;p&gt;第一种构建事务支持的应用程序方式是单进程模式。（进程可以是多线程的，也可以是单线程的）。&lt;/p&gt;

&lt;p&gt;当进程启动的时候，对环境执行&lt;a href=&quot;http://docs.oracle.com/cd/E17076_04/html/programmer_reference/transapp_recovery.html&quot;&gt;&lt;strong&gt;recovery&lt;/strong&gt;&lt;/a&gt;然后打开数据库环境。应用程序可以选择性地接着创建多个线程。这些线程可以共享已经打开的&lt;a href=&quot;http://docs.oracle.com/cd/E17076_04/html/api_reference/C/env.html&quot;&gt;** DB_ENV** &lt;/a&gt;和 &lt;strong&gt;&lt;a href=&quot;http://docs.oracle.com/cd/E17076_04/html/api_reference/C/db.html&quot;&gt;DB&lt;/a&gt;&lt;/strong&gt; 句柄，也可以创建它们自己的（注：一般情况下一个进程只会打开一个&lt;a href=&quot;http://docs.oracle.com/cd/E17076_04/html/api_reference/C/env.html&quot;&gt;&lt;strong&gt;DB_ENV&lt;/strong&gt;&lt;/a&gt;句柄）。在这种架构下，当有多个线程运行的时候，数据库很少被打开或关闭，数据库在只有一个线程运行的时候打开，在只剩一个线程的时候退出。最后一个线程负责关闭数据库以及数据库环境。&lt;/p&gt;

&lt;p&gt;这种架构是实现起来最简单的一种，因为线程的序列化开启很容易，错误检测也不需要监控多个进程。&lt;/p&gt;

&lt;p&gt;如果应用程序的线程模型允许进程在线程失败后继续执行，函数 &lt;a href=&quot;http://docs.oracle.com/cd/E17076_04/html/api_reference/C/envfailchk.html&quot;&gt;&lt;strong&gt;DB_ENV-&amp;gt;failchk()&lt;/strong&gt;&lt;/a&gt; 可以用来判断数据库环境在线程失败后是否可用。如果应用程序不执行 &lt;a href=&quot;http://docs.oracle.com/cd/E17076_04/html/api_reference/C/envfailchk.html&quot;&gt;&lt;strong&gt;DB_ENV-&amp;gt;failchk()&lt;/strong&gt;&lt;/a&gt; ，或者 &lt;a href=&quot;http://docs.oracle.com/cd/E17076_04/html/api_reference/C/envfailchk.html&quot;&gt;&lt;strong&gt;DB_ENV-&amp;gt;failchk()&lt;/strong&gt;&lt;/a&gt;  返回 &lt;a href=&quot;http://docs.oracle.com/cd/E17076_04/html/programmer_reference/program_errorret.html#program_errorret.DB_RUNRECOVERY&quot;&gt;&lt;strong&gt;DB_RUNRECOVERY&lt;/strong&gt;&lt;/a&gt; ，那么程序必须当做系统失败来处理，执行 &lt;a href=&quot;http://docs.oracle.com/cd/E17076_04/html/programmer_reference/transapp_recovery.html&quot;&gt;&lt;strong&gt;recovery&lt;/strong&gt;&lt;/a&gt; 并且重建数据库环境。一旦这些操作完成，其它线程就可以继续执行（只要所有存在的BDB 句柄都已经丢弃）。（注：句柄重新创建即可）&lt;/p&gt;

&lt;h3 id=&quot;2-多个相关进程&quot;&gt; 2 多个相关进程&lt;/h3&gt;

&lt;p&gt;第二种构建事务支持的应用程序方式是使用一组相关进程。（这些进程可以是单线程的，也可以是多线程的）&lt;/p&gt;

&lt;p&gt;这种架构需要根据控制线程被创建的顺序，来保证顺序的执行数据库环境恢复工作。&lt;/p&gt;

&lt;p&gt;除此之外，这种架构需要监控控制线程的行为。如果任何一个线程退出时有未关闭的 BDB 句柄，应用程序就需要调用 &lt;a href=&quot;http://docs.oracle.com/cd/E17076_04/html/api_reference/C/envfailchk.html&quot;&gt;&lt;strong&gt;DB_ENV-&amp;gt;failchk()&lt;/strong&gt;&lt;/a&gt;  去检测是否有丢失的 mutexes 和 locks 资源，以此决定应用程序是否能够继续执行。如果应用程序不调用 &lt;a href=&quot;http://docs.oracle.com/cd/E17076_04/html/api_reference/C/envfailchk.html&quot;&gt;&lt;strong&gt;DB_ENV-&amp;gt;failchk()&lt;/strong&gt;&lt;/a&gt;  或者 &lt;a href=&quot;http://docs.oracle.com/cd/E17076_04/html/api_reference/C/envfailchk.html&quot;&gt;&lt;strong&gt;DB_ENV-&amp;gt;failchk()&lt;/strong&gt;&lt;/a&gt;  返回结果表示数据库不可以继续使用，应用程序就当做发生系统错误来处理，执行 &lt;a href=&quot;http://docs.oracle.com/cd/E17076_04/html/programmer_reference/transapp_recovery.html&quot;&gt;&lt;strong&gt;recovery&lt;/strong&gt;&lt;/a&gt; 并创建一个新的数据库环境。一旦这些操作完成，其它控制线程就可以继续执行（只要恢复之前的BDB句柄被丢弃了）（注：重新创建了新的环境，其它句柄就要根据这个环境重新创建，之前的要丢弃，因为执行恢复的时候会删除）。&lt;/p&gt;

&lt;p&gt;构建一组相关进程最简单的方式是首先创建一个 “监控” 进程（通常是一个脚本），监控进程在整个系统启动的时候最先启动，执行&lt;a href=&quot;http://docs.oracle.com/cd/E17076_04/html/programmer_reference/transapp_recovery.html&quot;&gt;&lt;strong&gt;recovery&lt;/strong&gt;&lt;/a&gt; ，然后创建其它真正负责工作的进程。监控进程接下来只需要等待其它控制线程启动，确保它们不会意外退出。如果其中一个控制线程意外退出，监控进程可以选择性的调用 &lt;a href=&quot;http://docs.oracle.com/cd/E17076_04/html/api_reference/C/envfailchk.html&quot;&gt;&lt;strong&gt;DB_ENV-&amp;gt;failchk()&lt;/strong&gt;&lt;/a&gt;  。如果应用程序不调用 &lt;a href=&quot;http://docs.oracle.com/cd/E17076_04/html/api_reference/C/envfailchk.html&quot;&gt;&lt;strong&gt;DB_ENV-&amp;gt;failchk()&lt;/strong&gt;&lt;/a&gt;  或者 &lt;a href=&quot;http://docs.oracle.com/cd/E17076_04/html/api_reference/C/envfailchk.html&quot;&gt;&lt;strong&gt;DB_ENV-&amp;gt;failchk()&lt;/strong&gt;&lt;/a&gt;  返回结果表示数据库不可以继续使用，监控进程负责使用此环境的所有控制线程，执行&lt;a href=&quot;http://docs.oracle.com/cd/E17076_04/html/programmer_reference/transapp_recovery.html&quot;&gt;&lt;strong&gt;recovery&lt;/strong&gt;&lt;/a&gt;，并且开启新的控制线程来执行工作。（注：控制线程可以是一个进程，也可以是进程中的一个线程，表示使用BDB句柄访问数据库的一个执行流）。&lt;/p&gt;

&lt;h3 id=&quot;3-多个无关进程&quot;&gt; 3 多个无关进程&lt;/h3&gt;

&lt;p&gt;第三种方式就是使用多个无关的进程来架构（进程可以是多线程的也可以是单线程的）。这是实现起来最困难的一种架构方式，难度主要在于在一些系统上不容易寻找或监控不相关的进程。有许多技术去实现这种架构。&lt;/p&gt;

&lt;p&gt;其中一个解决方式是当打开BDB 句柄的时候记录控制线程的ID。举个例子，监控进程负责执行 &lt;a href=&quot;http://docs.oracle.com/cd/E17076_04/html/programmer_reference/transapp_recovery.html&quot;&gt;&lt;strong&gt;recovery&lt;/strong&gt;&lt;/a&gt; ，执行完毕后立刻创建一个哨兵文件（注：这很类似PG的锁文件postmaster.pid）。其它任何想要使用这个数据库环境的工作进程都需要检测哨兵文件。如果哨兵文件不存在，工作进程可以选择等待或者退出。一旦检测到哨兵文件存在，就将自己的进程ID注册到哨兵文件里面（通过共享内存，IPC或者其他注册机制），然后工作进程尽可以打开它的 &lt;a href=&quot;http://docs.oracle.com/cd/E17076_04/html/api_reference/C/env.html&quot;&gt;&lt;strong&gt;DB_ENV&lt;/strong&gt; &lt;/a&gt; 句柄并执行。当工作进程使用完毕数据库环境，它需要注销自己（在哨兵文件中删除自己的进程ID）。监控进程需要不断的检查以确保在使用数据库环境的过程中没有失败。如果工作进程在使用数据库环境过程中失败，监控进程就删除哨兵文件，同时杀死所有正在使用这个环境的工作进程，执行&lt;a href=&quot;http://docs.oracle.com/cd/E17076_04/html/programmer_reference/transapp_recovery.html&quot;&gt;&lt;strong&gt;recovery&lt;/strong&gt;&lt;/a&gt; ，然后重新创建哨兵文件。&lt;/p&gt;

&lt;p&gt;这种实现方式也有缺点，在某些系统上，很难判断不相关的进程是否仍然在运行。比如，POSIX 系统通常不允许给给不相关的进程发送信号。可以使用一些小手段，如使用一些在进程退出时状态会改变的系统资源，来实现对不相关进程的监控。在 POSIX 系统上，flock 或者 fcntl-style lock 都可以实现，就像Windows systems 上的LockFile 。其它系统可能会使用如文件引用计数，改变次数等进程相关的资源。在最糟糕的情况下，控制线程可能需要每隔一段时间就重新注册：如果监控进程在特定的时间间隔内没有收到工作进程的重新注册消息，就需要采取行动，恢复环境。&lt;/p&gt;

&lt;p&gt;BDB库含有一种内建的实现方式，在调用 &lt;a href=&quot;http://docs.oracle.com/cd/E17076_04/html/api_reference/C/envopen.html&quot;&gt;&lt;strong&gt;DB_ENV-&amp;gt;open()&lt;/strong&gt;&lt;/a&gt; 的时候使用 &lt;a href=&quot;http://docs.oracle.com/cd/E17076_04/html/api_reference/C/envopen.html#envopen_DB_REGISTER&quot;&gt;&lt;strong&gt;DB_REGISTER&lt;/strong&gt;&lt;/a&gt; 标记：&lt;/p&gt;

&lt;p&gt;如果使用了 &lt;a href=&quot;http://docs.oracle.com/cd/E17076_04/html/api_reference/C/envopen.html#envopen_DB_REGISTER&quot;&gt;&lt;strong&gt;DB_REGISTER&lt;/strong&gt;&lt;/a&gt; 标记，每一个试图打开数据库环境的进程首先会检查是否需要执行&lt;a href=&quot;http://docs.oracle.com/cd/E17076_04/html/programmer_reference/transapp_recovery.html&quot;&gt;&lt;strong&gt;recovery&lt;/strong&gt;&lt;/a&gt;。如果因为任何原因需要执行（包括第一次创建初始化环境），并且使用了 &lt;a href=&quot;http://docs.oracle.com/cd/E17076_04/html/api_reference/C/envopen.html#envopen_DB_RECOVER&quot;&gt;&lt;strong&gt;DB_RECOVER&lt;/strong&gt;&lt;/a&gt; 标记，那么将会执行 &lt;a href=&quot;http://docs.oracle.com/cd/E17076_04/html/programmer_reference/transapp_recovery.html&quot;&gt;&lt;strong&gt;recovery&lt;/strong&gt;&lt;/a&gt; 操作，接着正常开打数据库环境。如果如需要执行 &lt;a href=&quot;http://docs.oracle.com/cd/E17076_04/html/programmer_reference/transapp_recovery.html&quot;&gt;&lt;strong&gt;recovery&lt;/strong&gt;&lt;/a&gt;。但是没有指定 &lt;a href=&quot;http://docs.oracle.com/cd/E17076_04/html/api_reference/C/envopen.html#envopen_DB_RECOVER&quot;&gt;&lt;strong&gt;DB_RECOVER&lt;/strong&gt;&lt;/a&gt; 标记，将会返回&lt;a href=&quot;http://docs.oracle.com/cd/E17076_04/html/programmer_reference/program_errorret.html#program_errorret.DB_RUNRECOVERY&quot;&gt;&lt;strong&gt;DB_RUNRECOVERY&lt;/strong&gt;&lt;/a&gt; 错误。如果不需要执行&lt;a href=&quot;http://docs.oracle.com/cd/E17076_04/html/programmer_reference/transapp_recovery.html&quot;&gt;&lt;strong&gt;recovery&lt;/strong&gt;&lt;/a&gt;，&lt;a href=&quot;http://docs.oracle.com/cd/E17076_04/html/api_reference/C/envopen.html#envopen_DB_RECOVER&quot;&gt;&lt;strong&gt;DB_RECOVER&lt;/strong&gt;&lt;/a&gt; 标记将会被忽略。&lt;/p&gt;

&lt;p&gt;在真正的 &lt;a href=&quot;http://docs.oracle.com/cd/E17076_04/html/programmer_reference/transapp_recovery.html&quot;&gt;&lt;strong&gt;recovery&lt;/strong&gt;&lt;/a&gt; 操作执行之前，&lt;a href=&quot;http://docs.oracle.com/cd/E17076_04/html/api_reference/C/envevent_notify.html#event_notify_DB_EVENT_REG_PANIC&quot;&gt;&lt;strong&gt;DB_EVENT_REG_PANIC&lt;/strong&gt;&lt;/a&gt; 事件将会设置在数据库环境中。在进程中使用了 &lt;a href=&quot;http://docs.oracle.com/cd/E17076_04/html/api_reference/C/envevent_notify.html&quot;&gt;&lt;strong&gt;DB_ENV-&amp;gt;set_event_notify()&lt;/strong&gt;&lt;/a&gt; 方法的应用程序将会在下一次访问数据库环境的操作之前被更新（注：执行方法中设置的回调函数）。接收到这个事件的进程应该退出数据库环境。同样的，如果有其它进程加入到当前环境中，&lt;a href=&quot;http://docs.oracle.com/cd/E17076_04/html/api_reference/C/envevent_notify.html#event_notify_DB_EVENT_REG_ALIVE&quot;&gt;&lt;strong&gt;DB_EVENT_REG_ALIVE&lt;/strong&gt;&lt;/a&gt; 事件将会被触发。只有正在执行 &lt;a href=&quot;http://docs.oracle.com/cd/E17076_04/html/programmer_reference/transapp_recovery.html&quot;&gt;&lt;strong&gt;recovery&lt;/strong&gt;&lt;/a&gt; 操作的进程才会收到事件通知。这些进程会代表其它正在访问当前环境的进程接收一次此事件。 &lt;a href=&quot;http://docs.oracle.com/cd/E17076_04/html/api_reference/C/envevent_notify.html&quot;&gt;&lt;strong&gt;DB_ENV-&amp;gt;set_event_notify()&lt;/strong&gt;&lt;/a&gt; 方法的回调函数参数中包含了正在访问当前环境的所有进程描述符。这样，执行 &lt;a href=&quot;http://docs.oracle.com/cd/E17076_04/html/programmer_reference/transapp_recovery.html&quot;&gt;&lt;strong&gt;recovery&lt;/strong&gt;&lt;/a&gt; 操作的进程可以给访问环境的其它进程发送信号，或者在 &lt;a href=&quot;http://docs.oracle.com/cd/E17076_04/html/programmer_reference/transapp_recovery.html&quot;&gt;&lt;strong&gt;recovery&lt;/strong&gt;&lt;/a&gt; 操作之前执行一些其它的操作（比如，杀死其它进程）。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://docs.oracle.com/cd/E17076_04/html/api_reference/C/envset_timeout.html&quot;&gt;&lt;strong&gt;DB_ENV-&amp;gt;set_timeout()&lt;/strong&gt; &lt;/a&gt;方法的&lt;a href=&quot;http://docs.oracle.com/cd/E17076_04/html/api_reference/C/envset_timeout.html#set_timeout_DB_SET_REG_TIMEOUT&quot;&gt;&lt;strong&gt;DB_SET_REG_TIMEOUT&lt;/strong&gt;&lt;/a&gt; 标记设置后，将会在执行 &lt;a href=&quot;http://docs.oracle.com/cd/E17076_04/html/programmer_reference/transapp_recovery.html&quot;&gt;&lt;strong&gt;recovery&lt;/strong&gt;&lt;/a&gt; 操作之前等待一段时间。这就为其它进程接收到 &lt;a href=&quot;http://docs.oracle.com/cd/E17076_04/html/api_reference/C/envevent_notify.html#event_notify_DB_EVENT_REG_PANIC&quot;&gt;&lt;strong&gt;DB_EVENT_REG_PANIC&lt;/strong&gt;&lt;/a&gt; 事件并退出环境提供了一个时间窗口。&lt;/p&gt;

&lt;p&gt;接下来包含使用 &lt;a href=&quot;http://docs.oracle.com/cd/E17076_04/html/api_reference/C/envopen.html#envopen_DB_REGISTER&quot;&gt;&lt;strong&gt;DB_REGISTER&lt;/strong&gt;&lt;/a&gt; 架构的三种额外需求：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;首先，所有使用同一个环境的应用程序都需要在打开数据库环境的时候使用 &lt;a href=&quot;http://docs.oracle.com/cd/E17076_04/html/api_reference/C/envopen.html#envopen_DB_REGISTER&quot;&gt;&lt;strong&gt;DB_REGISTER&lt;/strong&gt;&lt;/a&gt; 标记，然而，如果应用程序仅仅选择使用一个进程来执行 &lt;a href=&quot;http://docs.oracle.com/cd/E17076_04/html/programmer_reference/transapp_recovery.html&quot;&gt;&lt;strong&gt;recovery&lt;/strong&gt;&lt;/a&gt; 操作，就不需要对其它进程使用 &lt;a href=&quot;http://docs.oracle.com/cd/E17076_04/html/api_reference/C/envopen.html#envopen_DB_REGISTER&quot;&gt;&lt;strong&gt;DB_REGISTER&lt;/strong&gt;&lt;/a&gt; 标记，因为第一个打开数据库的进程将会执行&lt;a href=&quot;http://docs.oracle.com/cd/E17076_04/html/programmer_reference/transapp_recovery.html&quot;&gt;&lt;strong&gt;recovery&lt;/strong&gt;&lt;/a&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;然后，每一个进程都只能拥有一个 &lt;a href=&quot;http://docs.oracle.com/cd/E17076_04/html/api_reference/C/env.html&quot;&gt;&lt;strong&gt;DB_ENV&lt;/strong&gt; &lt;/a&gt; 句柄，因为 &lt;a href=&quot;http://docs.oracle.com/cd/E17076_04/html/api_reference/C/envopen.html#envopen_DB_REGISTER&quot;&gt;&lt;strong&gt;DB_REGISTER&lt;/strong&gt;&lt;/a&gt; 锁是进程私有的，而不是线程私有的，一个环境下的多个 &lt;a href=&quot;http://docs.oracle.com/cd/E17076_04/html/api_reference/C/env.html&quot;&gt;&lt;strong&gt;DB_ENV&lt;/strong&gt; &lt;/a&gt; 句柄将会彼此竞争，存在数据损坏的潜在因素。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;第三点，&lt;a href=&quot;http://docs.oracle.com/cd/E17076_04/html/api_reference/C/envopen.html#envopen_DB_REGISTER&quot;&gt;&lt;strong&gt;DB_REGISTER&lt;/strong&gt;&lt;/a&gt; 在实现中并不会显示的终结正在恢复过程中的进程。而是需要靠进程自己注意到数据库环境已经默默的被丢弃了。根据这个原因，&lt;a href=&quot;http://docs.oracle.com/cd/E17076_04/html/api_reference/C/envopen.html#envopen_DB_REGISTER&quot;&gt;&lt;strong&gt;DB_REGISTER&lt;/strong&gt;&lt;/a&gt; 标记应该在 mutex 变量不会在操作系统层面阻塞的环境中使用，否则就会存在一个控制线程等待一个永远无法获得的 mutex 变量而永远阻塞的风险。使用任何 test-and-set mutex 变量实现将确保这种情况不会发生，基于这个原因，&lt;a href=&quot;http://docs.oracle.com/cd/E17076_04/html/api_reference/C/envopen.html#envopen_DB_REGISTER&quot;&gt;&lt;strong&gt;DB_REGISTER&lt;/strong&gt;&lt;/a&gt; 标记通常与 test-and-set mutext 实现一起使用。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(注：项目中使用 &lt;strong&gt;&lt;a href=&quot;http://docs.oracle.com/cd/E17076_04/html/api_reference/C/envopen.html#envopen_DB_REGISTER&quot;&gt;DB_REGISTER&lt;/a&gt; &lt;/strong&gt; 的方式，除了上面说的缺点，还有可能发生另一种隐含的错误。使用 &lt;a href=&quot;http://docs.oracle.com/cd/E17076_04/html/api_reference/C/envopen.html#envopen_DB_REGISTER&quot;&gt;&lt;strong&gt;DB_REGISTER&lt;/strong&gt;&lt;/a&gt; 标记会在数据库环境目录下创建文件__db.register，里面记录每一个打开环境的控制线程标记，也就线程号或者进程号，退出的时候会在其中注销掉自己的ID，这样表示安全使用环境并正常的关闭，不需要执行&lt;a href=&quot;http://docs.oracle.com/cd/E17076_04/html/programmer_reference/transapp_recovery.html&quot;&gt;&lt;strong&gt;recovery&lt;/strong&gt;&lt;/a&gt; 操作，如果异常退出没有注销，BDB会按照 ID 去判断对应的进程/线程是否存在，如果不存在则说明异常退出，需要执行&lt;a href=&quot;http://docs.oracle.com/cd/E17076_04/html/programmer_reference/transapp_recovery.html&quot;&gt;&lt;strong&gt;recovery&lt;/strong&gt;&lt;/a&gt; 操作。如果遇到这种情况：进程首先打开数据库环境并注册自己，接着因为应用程序需要，整个进程变成守护进程去后台执行，守护进程需要继承父进程的BDB资源，不能够退出并释放。但此时进程的ID已经变了，注册的是父进程的ID，父进程已经退出。正在运行的是子进程。此时BDB根据__db.register 文件判断进程异常退出了，执行&lt;a href=&quot;http://docs.oracle.com/cd/E17076_04/html/programmer_reference/transapp_recovery.html&quot;&gt;&lt;strong&gt;recovery&lt;/strong&gt;&lt;/a&gt; 操作，导致守护进程获得 &lt;a href=&quot;http://docs.oracle.com/cd/E17076_04/html/programmer_reference/program_errorret.html#program_errorret.DB_RUNRECOVERY&quot;&gt;&lt;strong&gt;DB_RUNRECOVERY&lt;/strong&gt;&lt;/a&gt; 错误并退出。这种情况下需要控制应用程序的行为。)&lt;/p&gt;

&lt;p&gt;对于多个无关进程的第二种解决方式也是基于“观察进程”的。这种实现方式适用于对共享环境的进程监控要求不是那么苛刻的情况下，但是仍然需要监控是否有一个拥有 BDB 句柄的控制线程执行失败。可以这样实现：使用一个“观察”进程每隔一段时间调用 &lt;a href=&quot;http://docs.oracle.com/cd/E17076_04/html/api_reference/C/envfailchk.html&quot;&gt;&lt;strong&gt;DB_ENV-&amp;gt;failchk()&lt;/strong&gt;&lt;/a&gt; 。如果 &lt;a href=&quot;http://docs.oracle.com/cd/E17076_04/html/api_reference/C/envfailchk.html&quot;&gt;&lt;strong&gt;DB_ENV-&amp;gt;failchk()&lt;/strong&gt;&lt;/a&gt;  返回表示环境不能继续被使用，“观察”进程就需要采取行动，恢复环境。&lt;/p&gt;

&lt;p&gt;这种方式的缺点就是所有的控制线程必须使用方法 &lt;a href=&quot;http://docs.oracle.com/cd/E17076_04/html/api_reference/C/envset_thread_id.html&quot;&gt;&lt;strong&gt;DB_ENV-&amp;gt;set_thread_id()&lt;/strong&gt;&lt;/a&gt; 来指定一个获得ID的方法和判断仍然在运行的方法（换句话说，BDB 库必须对每一个控制线程指定唯一的 ID ，除此之外还要能够判断控制线程是否仍然在运行。对于使用不同语言实现的，或运行在不同平台上的应用程序，想要提供这些消息还是有难度的）。&lt;/p&gt;

&lt;p&gt;对于多个无关进程的第三种解决方式是上面两种方式的结合。使用 &lt;a href=&quot;http://docs.oracle.com/cd/E17076_04/html/api_reference/C/envopen.html&quot;&gt;&lt;strong&gt;DB_ENV-&amp;gt;open()&lt;/strong&gt;&lt;/a&gt; 方法同时指定 &lt;a href=&quot;http://docs.oracle.com/cd/E17076_04/html/api_reference/C/envopen.html#envopen_DB_REGISTER&quot;&gt;&lt;strong&gt;DB_REGISTER&lt;/strong&gt;&lt;/a&gt; 和&lt;a href=&quot;http://docs.oracle.com/cd/E17076_04/html/api_reference/C/envopen.html#envopen_DB_FAILCHK&quot;&gt;&lt;strong&gt;DB_FAILCHK&lt;/strong&gt;&lt;/a&gt; 标记。当同时指定这两种标记的时候，每一个打开数据库环境的进程首先检查是否需要执行 &lt;a href=&quot;http://docs.oracle.com/cd/E17076_04/html/programmer_reference/transapp_recovery.html&quot;&gt;&lt;strong&gt;recovery&lt;/strong&gt;&lt;/a&gt; 。如果因为任何原因需要执行，首先判断是否有控制线程在退出时拥有数据库读锁，如果有，就释放它们。接着将会 abort 任何没有完成的事务。如果这几个步骤都成功的完成了，进程打开数据库环境的操作将会继续执行，不需要额外的恢复操作。如果这几步失败了，并且指定了&lt;a href=&quot;http://docs.oracle.com/cd/E17076_04/html/api_reference/C/envopen.html#envopen_DB_RECOVER&quot;&gt;&lt;strong&gt;DB_RECOVER&lt;/strong&gt;&lt;/a&gt; 标记，额外的 &lt;a href=&quot;http://docs.oracle.com/cd/E17076_04/html/programmer_reference/transapp_recovery.html&quot;&gt;&lt;strong&gt;recovery&lt;/strong&gt;&lt;/a&gt; 操作就会被执行，如果没有指定 &lt;a href=&quot;http://docs.oracle.com/cd/E17076_04/html/api_reference/C/envopen.html#envopen_DB_RECOVER&quot;&gt;&lt;strong&gt;DB_RECOVER&lt;/strong&gt;&lt;/a&gt; 标记，&lt;a href=&quot;http://docs.oracle.com/cd/E17076_04/html/programmer_reference/program_errorret.html#program_errorret.DB_RUNRECOVERY&quot;&gt;&lt;strong&gt;DB_RUNRECOVERY&lt;/strong&gt;&lt;/a&gt; 错误就会被返回。&lt;/p&gt;

&lt;p&gt;因为这种方式是前面两种方式的结合，前面两种方式所有的需求都必须实现（将会需要获得 ID 的方法，判断是否正在运行的方法，每个数据库唯一一个 &lt;a href=&quot;http://docs.oracle.com/cd/E17076_04/html/api_reference/C/env.html&quot;&gt;&lt;strong&gt;DB_ENV&lt;/strong&gt; &lt;/a&gt; 句柄等等）。&lt;/p&gt;

&lt;p&gt;上面描述的三种方法是不同的，而且不应该被结合起来使用。应用程序应该使用 &lt;a href=&quot;http://docs.oracle.com/cd/E17076_04/html/api_reference/C/envopen.html#envopen_DB_REGISTER&quot;&gt;&lt;strong&gt;DB_REGISTER&lt;/strong&gt;&lt;/a&gt; 方式，或者 &lt;a href=&quot;http://docs.oracle.com/cd/E17076_04/html/api_reference/C/envfailchk.html&quot;&gt;&lt;strong&gt;DB_ENV-&amp;gt;failchk()&lt;/strong&gt;&lt;/a&gt; 方式，或者两种方式结合的实现方法，但是不应该在一个应用程序中使用超过其中一种。比如，一个 POSIX 的应用程序，在实现中使用了大量多种多样的接口和不同的 API，可能会使用 &lt;a href=&quot;http://docs.oracle.com/cd/E17076_04/html/api_reference/C/envopen.html#envopen_DB_REGISTER&quot;&gt;&lt;strong&gt;DB_REGISTER&lt;/strong&gt;&lt;/a&gt; 的实现方式，有以下几个原因：1 不需要间歇性的调用函数 &lt;a href=&quot;http://docs.oracle.com/cd/E17076_04/html/api_reference/C/envfailchk.html&quot;&gt;&lt;strong&gt;DB_ENV-&amp;gt;failchk()&lt;/strong&gt;&lt;/a&gt;  ；2 当使用多种语言实现的时候，每个控制线程获得唯一的 ID 会更加困难；3 判断一个控制线程是否仍然在运行更加困难，任何特殊的控制线程（注：指执行&lt;a href=&quot;http://docs.oracle.com/cd/E17076_04/html/programmer_reference/transapp_recovery.html&quot;&gt;&lt;strong&gt;recovery&lt;/strong&gt;&lt;/a&gt;操作的控制线程）可能没有足够的权利向其它进程发送信号。作为另一种选择，拥有专门的“监控”进程的应用程序，同时拥有适当的权力，为了支持更高的吞吐量和更好的可靠性，可能选择 &lt;a href=&quot;http://docs.oracle.com/cd/E17076_04/html/api_reference/C/envfailchk.html&quot;&gt;&lt;strong&gt;DB_ENV-&amp;gt;failchk()&lt;/strong&gt;&lt;/a&gt;  方式，因为这种方式允许应用程序 abort 没有决定的事务并且不一定需要 &lt;a href=&quot;http://docs.oracle.com/cd/E17076_04/html/programmer_reference/transapp_recovery.html&quot;&gt;&lt;strong&gt;recovery&lt;/strong&gt;&lt;/a&gt; 就可以继续运行。第三种方式适用于使用“监控”进程并不是特别实用，但是在调用 &lt;a href=&quot;http://docs.oracle.com/cd/E17076_04/html/api_reference/C/envopen.html&quot;&gt;&lt;strong&gt;DB_ENV-&amp;gt;open()&lt;/strong&gt;&lt;/a&gt; 之前执行 &lt;a href=&quot;http://docs.oracle.com/cd/E17076_04/html/api_reference/C/envfailchk.html&quot;&gt;&lt;strong&gt;DB_ENV-&amp;gt;failchk()&lt;/strong&gt;&lt;/a&gt;  非常重要的情况之下。&lt;/p&gt;

&lt;p&gt;显而易见，当使用一个独立的进程去监控其它控制线程，这个进程的需要尽可能的简单并且可调试，应为如果这个进程失败，整个应用程序都会挂起。&lt;/p&gt;
</description>
        <pubDate>Thu, 18 Feb 2016 17:26:08 +0800</pubDate>
        <link>http://localhost:4000/berkeley%20db/computer%20science/2016/02/18/berkeley-db-e4-ba-8b-e5-8a-a1-e6-94-af-e6-8c-81-e7-9a-84-e5-ba-94-e7-94-a8-e6-9e-b6-e6-9e-84/</link>
        <guid isPermaLink="true">http://localhost:4000/berkeley%20db/computer%20science/2016/02/18/berkeley-db-e4-ba-8b-e5-8a-a1-e6-94-af-e6-8c-81-e7-9a-84-e5-ba-94-e7-94-a8-e6-9e-b6-e6-9e-84/</guid>
        
        <category>Berkeley DB</category>
        
        <category>Database</category>
        
        
        <category>Berkeley DB</category>
        
        <category>computer science</category>
        
      </item>
    
      <item>
        <title>PostgreSQL 客户端认证机制</title>
        <description>&lt;p&gt;最近实验室数据库需要提高安全性，因为以前只有自己人用，基本上是在裸奔，知道端口号和IP就可以连接上，不需要任何认证信息，没有安全可言。最简单的认证方式就是用户名和密码，但平常使用PG的时候都没有用到，就研究了一下PG的认证方式，取取经。&lt;/p&gt;

&lt;h3 id=&quot;配置与使用&quot;&gt;配置与使用&lt;/h3&gt;

&lt;p&gt;PG的认证方式有很多种，而且对于不同的database，不同的user，不同的访问IP都可以选择不同的方式认证。具体在配置文件pg_hba.conf中说明。&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;local&lt;/td&gt;
      &lt;td&gt;DATABASE &lt;/td&gt;
      &lt;td&gt;USER &lt;/td&gt;
      &lt;td&gt;METHOD &lt;/td&gt;
      &lt;td&gt;[OPTIONS]&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;host&lt;/td&gt;
      &lt;td&gt;DATABASE &lt;/td&gt;
      &lt;td&gt;USER &lt;/td&gt;
      &lt;td&gt;ADDRESS &lt;/td&gt;
      &lt;td&gt;METHOD &lt;/td&gt;
      &lt;td&gt;[OPTIONS]&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;hostssl&lt;/td&gt;
      &lt;td&gt;DATABASE &lt;/td&gt;
      &lt;td&gt;USER &lt;/td&gt;
      &lt;td&gt;ADDRESS &lt;/td&gt;
      &lt;td&gt;METHOD &lt;/td&gt;
      &lt;td&gt;[OPTIONS]&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;hostnossl&lt;/td&gt;
      &lt;td&gt;DATABASE &lt;/td&gt;
      &lt;td&gt;USER &lt;/td&gt;
      &lt;td&gt;ADDRESS &lt;/td&gt;
      &lt;td&gt;METHOD &lt;/td&gt;
      &lt;td&gt;[OPTIONS]&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;配置的时候大写字母要被对应的内容所取代。&lt;/p&gt;

&lt;p&gt;其中local匹配本地Unix域套接字访问。host 对应TCP/IP的链接认证，即可以匹配SSL链接请求，也可以匹配非SSL链接请求。hostssl 匹配使用TCP/IP的SSL链接请求，如果需要PG支持SSL，需要在客户端和服务器端安装openSSL，并且在编译阶段使用 –with-openssl，具体配置参考&lt;strong&gt;&lt;a href=&quot;http://www.postgresql.org/docs/9.5/interactive/install-procedure.html&quot;&gt;这里&lt;/a&gt;&lt;/strong&gt;。Hostnossl匹配普通的TCP/IP 链接。&lt;/p&gt;

&lt;p&gt;后面内容与字面描述一致，ADDRESS使用CIDR-address（IP/掩码）格式，声明匹配的客户端IP地址范围。METHOD是具体的认证方式，OPTION是具体认证方式可以配置的选项，以name-value的形式出现。例如：&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;local&lt;/td&gt;
      &lt;td&gt;all&lt;/td&gt;
      &lt;td&gt;all&lt;/td&gt;
      &lt;td&gt;127.0.0.1/32&lt;/td&gt;
      &lt;td&gt;md5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;host&lt;/td&gt;
      &lt;td&gt;postgres&lt;/td&gt;
      &lt;td&gt;all&lt;/td&gt;
      &lt;td&gt;192.168.12.10/32&lt;/td&gt;
      &lt;td&gt;md5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;host&lt;/td&gt;
      &lt;td&gt;all&lt;/td&gt;
      &lt;td&gt;all&lt;/td&gt;
      &lt;td&gt;192.168.0.0/16&lt;/td&gt;
      &lt;td&gt;ident map=omicron&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;第一个表示本地使用Unix域套接字访问，任何用户访问任何数据库的认证方式都是md5。安装PG后对本地的访问默认是trust, 更改为md5后使用psql登录：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;postgres@ubuntu:~&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;psql
Password:
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;默认登陆的是postgres数据库，初始是没有密码的，输入任何密码都会被拒绝，需要在后台设置密码：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    alter role postgres password &lt;span class=&quot;s1&quot;&gt;'your password'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;密码会使用md5加密保存，并且会在系统内部随机生成一个四位大小的随机数，和明文密码一起经过md5加密，为了提高破解的难度，也称作“加盐”。&lt;/p&gt;

&lt;p&gt;ident 认证方式是比较登录PG的用户和登录客户端的用户名是否相同，假设使用用户名messi登录了linux，在此账户下访问PG，如果访问的数据库用户不是messi，就不允许登陆。但是大多数情况下，两个用户名并不相同，所以PG提供了另一个映射文件：pg_ident.conf ，其中内容格式如下：&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;map-name&lt;/td&gt;
      &lt;td&gt;system-username&lt;/td&gt;
      &lt;td&gt;database-username&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;omicron&lt;/td&gt;
      &lt;td&gt;iniesta&lt;/td&gt;
      &lt;td&gt;messi&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;omicron 是map的名字，在上述第三个例子中定义ident，此时登录OS的用户是iniesta，但可以访问PG中用户为messi的数据库。如果system-username字段以一个反斜杠(/)开始， 那么该字段的剩余部分被作为一个规则表达式对待。可以参看&lt;strong&gt;&lt;a href=&quot;http://www.postgresql.org/docs/9.5/interactive/functions-matching.html#FUNCTIONS-POSIX-REGEXP&quot;&gt;PG的正则表达式语法&lt;/a&gt;&lt;/strong&gt;。除了md5，ident认证方式，还有其它多种认证方式，请参看&lt;strong&gt;&lt;a href=&quot;http://www.postgresql.org/docs/9.5/interactive/client-authentication.html&quot;&gt;官方文档&lt;/a&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;h3 id=&quot;源码解析&quot;&gt; 源码解析&lt;/h3&gt;

&lt;p&gt;当postmaster启动的时候，会读取并解析上述两个配置文件，分别调用load_hba() load_ident() 两个函数，这两个函数会逐行的解析里面的内容，每一行的内容都有一个对应的数据结构来描述，分别是：&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IdentLine&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;linenumber&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;        &lt;span class=&quot;cm&quot;&gt;/*记录行号*/&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;	   &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;usermap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;        &lt;span class=&quot;cm&quot;&gt;/*map名*/&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;	   &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ident_user&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;     &lt;span class=&quot;cm&quot;&gt;/*认证的用户，也就是需要映射的OS登录用户名*/&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;	   &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pg_role&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;        &lt;span class=&quot;cm&quot;&gt;/*pg 角色名*/&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;regex_t&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;re&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;         &lt;span class=&quot;cm&quot;&gt;/*正则表达式*/&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IdentLine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HbaLine&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;linenumber&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/*记录行号*/&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;	   &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rawline&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;           &lt;span class=&quot;cm&quot;&gt;/*原本的内容*/&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ConnType&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;conntype&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;      &lt;span class=&quot;cm&quot;&gt;/*链接类型*/&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;	   &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;databases&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;         
    &lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;	   &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;roles&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;      
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sockaddr_storage&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;addr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/*IP地址范围*/&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sockaddr_storage&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/*子网掩码*/&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;IPCompareMethod&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ip_cmp_method&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;	   &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hostname&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;UserAuth&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;auth_method&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;cm&quot;&gt;/*认证方式 md5 ident等*/&lt;/span&gt;

    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;	   &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;usermap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;          &lt;span class=&quot;cm&quot;&gt;/*ident map名*/&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;	   &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pamservice&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;       &lt;span class=&quot;cm&quot;&gt;/*PAM服务*/&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;ldaptls&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;      &lt;span class=&quot;cm&quot;&gt;/*ldap中是否使用TLS*/&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;	   &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ldapserver&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;       
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;ldapport&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;	   &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ldapbinddn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;	   &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ldapbindpasswd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;	   &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ldapsearchattribute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;	   &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ldapbasedn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;			&lt;span class=&quot;n&quot;&gt;ldapscope&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;	   &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ldapprefix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;	   &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ldapsuffix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;clientcert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;     &lt;span class=&quot;cm&quot;&gt;/*ssl客户端证书认证*/&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;	   &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;krb_server_hostname&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/*krb 服务器名*/&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;	   &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;krb_realm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;include_realm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;	   &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;radiusserver&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;      &lt;span class=&quot;cm&quot;&gt;/*radi服务名*/&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;	   &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;radiussecret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;	   &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;radiusidentifier&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;			&lt;span class=&quot;n&quot;&gt;radiusport&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;HbaLine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;逐行解析并放入这两个数据结构中，存放内容的空间会在特定的内存上下文中。解析完毕后会用PG中的List结构把每一行组成一个链表，分别会有静态全局变量指向链表头，以备后续认证访问。当postmaster正在运行，如果想改变认证方式，修改配置文件后需要发送SIGHUP信号，或者执行pg_ctl -D ./DATADIR reload命令，会重新读取配置文件。&lt;/p&gt;

&lt;p&gt;具体的认证行为在postgres进程中，因为PG的多进程架构，当新的链接请求到达pastmaster之后，会fork一个postgres进程进行处理，上述解析的内容也会从postmaster继承过来，但是postmaster重新读配置文件解析后，却不会影响已经执行的postgres，大多数情况postgres正在运行说明已经通过了验证，也不用理会认证方式的改变。一个新链接包含的内容保存在 Port 这个数据结构中，也有一个全局的指针指向它，在认证过程中与客户端的通信都是基于Port中的文件描述符。postgres也许并不需要关心此链接是一个本地的Unix域套接字，还是网络Socket。也把Port这个结构贴出来，源码里面的注释已经挺明白的：&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Port&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;pgsocket&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;sock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;			&lt;span class=&quot;cm&quot;&gt;/* File descriptor */&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;noblock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;		&lt;span class=&quot;cm&quot;&gt;/* is the socket in non-blocking mode? */&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ProtocolVersion&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;proto&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;		&lt;span class=&quot;cm&quot;&gt;/* FE/BE protocol version */&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;SockAddr&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;laddr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;			&lt;span class=&quot;cm&quot;&gt;/* local addr (postmaster) */&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;SockAddr&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;raddr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;			&lt;span class=&quot;cm&quot;&gt;/* remote addr (client) */&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;	   &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;remote_host&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;	&lt;span class=&quot;cm&quot;&gt;/* name (or ip addr) of remote host */&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;	   &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;remote_hostname&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;cm&quot;&gt;/* name (not ip addr) of remote host, if
                                 * available */&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;			&lt;span class=&quot;n&quot;&gt;remote_hostname_resolv&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* see above */&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;	   &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;remote_port&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;	&lt;span class=&quot;cm&quot;&gt;/* text rep of remote port */&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;CAC_state&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;canAcceptConnections&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;	&lt;span class=&quot;cm&quot;&gt;/* postmaster connection status */&lt;/span&gt;

    &lt;span class=&quot;cm&quot;&gt;/*
     * Information that needs to be saved from the startup packet and passed
     * into backend execution.  &quot;char *&quot; fields are NULL if not set.
     * guc_options points to a List of alternating option names and values.
     */&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;	   &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;database_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;	   &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;user_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;	   &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cmdline_options&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;	   &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;guc_options&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;cm&quot;&gt;/*
     * Information that needs to be held during the authentication cycle.
     */&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;HbaLine&lt;/span&gt;    &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hba&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;		&lt;span class=&quot;n&quot;&gt;md5Salt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;		&lt;span class=&quot;cm&quot;&gt;/* Password salt */&lt;/span&gt;

    &lt;span class=&quot;cm&quot;&gt;/*
     * Information that really has no business at all being in struct Port,
     * but since it gets used by elog.c in the same way as database_name and
     * other members of this struct, we may as well keep it here.
     */&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;TimestampTz&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SessionStartTime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;		&lt;span class=&quot;cm&quot;&gt;/* backend start time */&lt;/span&gt;

    &lt;span class=&quot;cm&quot;&gt;/*
     * TCP keepalive settings.
     *
     * default values are 0 if AF_UNIX or not yet known; current values are 0
     * if AF_UNIX or using the default. Also, -1 in a default value means we
     * were unable to find out the default (getsockopt failed).
     */&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;			&lt;span class=&quot;n&quot;&gt;default_keepalives_idle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;			&lt;span class=&quot;n&quot;&gt;default_keepalives_interval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;			&lt;span class=&quot;n&quot;&gt;default_keepalives_count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;			&lt;span class=&quot;n&quot;&gt;keepalives_idle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;			&lt;span class=&quot;n&quot;&gt;keepalives_interval&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;			&lt;span class=&quot;n&quot;&gt;keepalives_count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;cp&quot;&gt;#if defined(ENABLE_GSS) || defined(ENABLE_SSPI)
&lt;/span&gt;
    &lt;span class=&quot;cm&quot;&gt;/*
     * If GSSAPI is supported, store GSSAPI information. Otherwise, store a
     * NULL pointer to make sure offsets in the struct remain the same.
     */&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;pg_gssinfo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gss&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#else
&lt;/span&gt;    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;	   &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gss&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#endif
&lt;/span&gt;
    &lt;span class=&quot;cm&quot;&gt;/*
     * SSL structures (keep these last so that USE_SSL doesn't affect
     * locations of other fields)
     */&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#ifdef USE_SSL
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;SSL&lt;/span&gt;		   &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ssl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;X509&lt;/span&gt;	   &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;peer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;	   &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;peer_cn&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#endif
&lt;/span&gt;
    &lt;span class=&quot;cm&quot;&gt;/* This field will be in a saner place in 9.4 and up */&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;			&lt;span class=&quot;n&quot;&gt;remote_hostname_errcode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;		&lt;span class=&quot;cm&quot;&gt;/* see above */&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Port&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;可以看到，和客户端认证相关的除了基本的信息，比如要访问的数据库，客户端的地址，用户名等，里面包含了一个HbaLine 指针和 md5Salt。认证的入口是InitProcess函数，最终会调用ClientAuthentication，首先根据访问信息去匹配满足要求的HbaLine，如果匹配不到就会报错并退出数据库。接着验证客户端证书（如果有），然后就根据认证方式进入不同的认证方式分支。认证过程会进行多次通信。最终得到认证结果选择是否中断链接。&lt;/p&gt;

&lt;p&gt;以md5认证方式为例，第一步需要组装信息发送给客户端，要求客户端输入密码。具体发送消息的格式如下：&lt;/p&gt;
&lt;table&gt;
&lt;tbody&gt;
&lt;tr&gt;

&lt;td width=&quot;184&quot;&gt;Type（‘R’char）
&lt;/td&gt;

&lt;td width=&quot;184&quot;&gt;Type（MD5 int）
&lt;/td&gt;

&lt;td width=&quot;184&quot;&gt;Salt（char[4]）
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;一个值为‘R’的char，表示需要客户端回应，接着是认证的类型，客户端根据类型做不同信息相应，最后是MD5特有的“盐”值，需要从数据库中取出来，发送给客户端，让客户端完成加密工作。第二步就是等待客户端发送过来的密码，与数据库的密码进行比对，完成验证。这里最重要的就是客户端需要统一信息发送接收和解析的格式。&lt;/p&gt;

&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;

&lt;p&gt;PG的多进程架构让认证流程变得很清晰，项目中采用多线程+epoll处理多个链接，逻辑就会稍微复杂一点。如果SSL加密可靠，似乎可以在网络上传送密码的明文，所有加密工作可以放到数据库端来做，这样客户端就少了一道加密的工作。关于ident认证方式，某种程度上借用了OS登录认证的保护，值得借鉴。&lt;/p&gt;

&lt;h3 id=&quot;参考&quot;&gt;参考&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;http://product.dangdang.com/22552056.html&quot;&gt;&lt;strong&gt;PostgreSQL 数据库内核分析&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;http://www.jb51.net/article/40300.htm&lt;/strong&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 22 Jan 2016 20:48:30 +0800</pubDate>
        <link>http://localhost:4000/computer%20science/database/2016/01/22/postgresql-e5-ae-a2-e6-88-b7-e7-ab-af-e8-ae-a4-e8-af-81-e6-9c-ba-e5-88-b6/</link>
        <guid isPermaLink="true">http://localhost:4000/computer%20science/database/2016/01/22/postgresql-e5-ae-a2-e6-88-b7-e7-ab-af-e8-ae-a4-e8-af-81-e6-9c-ba-e5-88-b6/</guid>
        
        <category>PostgreSQL</category>
        
        
        <category>computer science</category>
        
        <category>database</category>
        
      </item>
    
      <item>
        <title>再见2015</title>
        <description>&lt;p&gt;2015年马上就要结束了，感觉过的好快，不过仔细想想这一年还是经历了挺多事，当然也少不了有遗憾。不管好的坏的，都是今天总结的下酒菜。&lt;/p&gt;

&lt;h3 id=&quot;dpinm&quot;&gt;DPINM&lt;/h3&gt;

&lt;p&gt;这是今年开始做的项目，D是分布式，P是并行，INM是实验室的数据库名字。名字不是我起的，因为开始时候一头雾水，都不知道能不能做得好，还即要并行，又要分布。当时还是挺期待这个项目了，因为单机版数据师兄师姐已经写了几代了，剩下多是修修补补的工作。这对我们来说不是分析，设计，代码，完成这种流程就能搞定的，因为刚开始的时候根本不知道要如何下手。分布的动机是单机版的处理能力有限，比如插入数据一多，内存就爆了，根本插入不进去（当然这是设计的问题），速度也慢了。所以我们开始分析单机的瓶颈在哪。用了新买的内存超大的机器运行，没有出现内存爆的情况。这样的工作持续了一段时间，分布式方向始终没有进展，明明开始了一个新的项目，却不知道具体要做什么，有同学就很迷茫，甚至提出要退出，觉得这是在浪费时间。经历一段比较尴尬的时期。作为项目组唯一一个有Y染色体的，开始 take over。第一步，不管怎样，先要让系统转起来吧，这样大家看到一个比较具体的东西才不会迷茫。通信是分布的前提，自己动手写一个网络层的通信虽然灵活，但是进度太慢。于是结识了&lt;a href=&quot;http://www.zhangxiaojian.name/?p=403&quot;&gt;&lt;strong&gt;MPI&lt;/strong&gt;&lt;/a&gt;，用于集群间的信息传递，还有进程管理。搭好环境，这时算是有了眉目，用一致性Hash把数据分到不同机器即可。但是原有接口出现很多问题，比如Instance的ID空间就会重复，使用Instance的名字Hash分配，名字是否能确定不会重复等等。为了使逻辑层尽可能的不改动，对上层提供了统一的接口，如果在本地找不到的数据，就透明的去其它节点请求。像这样：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/img/uploads/2015/12/zj1.png&quot;&gt;&lt;img src=&quot;/img/uploads/2015/12/zj1.png&quot; alt=&quot;zj1&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;项目终于可以转起来了，大家可以在自己负责的模块进行分布式的探索。这时候在内存管理方面遇到了麻烦，因为MPI负责通信，我把它设计成单例模式，为了避免频繁接收消息需要分配空间，就预分配了一定的空间，但是发送接收都要走这里，很容易覆盖读写。而且INM中实例的部分反序列化的，从其它节点接收到的数据不能立刻释放，接收节点容易忘记释放，出现内存泄漏。这种问题想到了上课时候PostgreSQL中的一个特性——&lt;a href=&quot;http://www.zhangxiaojian.name/?p=447&quot;&gt;&lt;strong&gt;内存上下文&lt;/strong&gt;&lt;/a&gt;，提供一种调度机制解决频繁分配空间的问题，还可以避免内存泄漏，完美！于是花了一段时间把它读懂，用C++重写了一下，正好赶上&lt;a href=&quot;http://totemdb.whu.edu.cn/personal/ywpeng/pg2015/&quot;&gt;&lt;strong&gt;PG象行活动武汉大学站&lt;/strong&gt;&lt;/a&gt;，靠&lt;a href=&quot;http://totemdb.whu.edu.cn/personal/ywpeng/index_cn.html&quot;&gt;&lt;strong&gt;彭老师&lt;/strong&gt;&lt;/a&gt;罩，做了一次分享。下面可是不少业界的大牛啊，下午还有机会交流了下，收获很多。&lt;/p&gt;

&lt;p&gt;当然，一个分布式数据库要做的工作还有很多，虽然老板看到系统能用很High，我知道离核心的东西还远。基本上此时开发进入一个停滞期，开始阅读分布式的书籍，论文。不得不说我此前对论文是有偏见的，可能是小时候看&lt;a href=&quot;http://blog.sina.com.cn/u/1191258123&quot;&gt;&lt;strong&gt;韩寒&lt;/strong&gt;&lt;/a&gt;太多，总觉得是把人都能看懂的东西写的鬼都看不懂。因为毕业要求发论文，不能不硬着头皮看，看了很多分布式事务处理，系统设计，CAP，Replication，HA，Zookeeper等等。发现很多东西论文讲的很清楚，很到位。系统设计的可能不是很详细，不足以作为参考写出一个数据库，但很多思想都是博客，书籍里面体会不到的。经过这段时期，已经对要做的事比较清楚了，具体的设计已经有了眉目，更加具体的实现就要留到明年再做了！&lt;/p&gt;

&lt;h3 id=&quot;football&quot;&gt;FootBall&lt;/h3&gt;

&lt;p&gt;这一年的足球生活也算精彩，因为是本命年，按照多灾多难的歪理邪说应该命运多舛（成语有毒）。我本来估计最有可能受伤的地方就是球场了，做好了迎接血光之灾的准备，却没想到最美好的事发生在了球场。虽然早就加入了院队，但没有真正融入，一开始参加校赛连名单都没进，我一怒之下都不打算再去了。不过后来想想该去还是要去，不去才是怂了。果然，韩寒这次说对了，怀才就像怀孕，时间久了总能看出来。现在想想，如果真的不去了，那得错过多少啊。之后参加了&lt;strong&gt;五人制比赛&lt;/strong&gt;，赶上了学校第一届，相比全场，还是更喜欢踢这种小的，很早就想踢一次正式的五人制比赛，总算实现了。&lt;strong&gt;足协杯&lt;/strong&gt;，踢的是8人半场，大家对这个比赛并不太重视，因为各种瞎组队，出成绩的机会比较少，从这次比赛我竟然觉得踢边后卫是很爽的，小组赛第二场进了第一个球和3：2落后扳平的一个球。虽然最后还是5：3输了，但我感觉和赢了一样。加上后来发生的事我才知道，这场比赛有多值得怀念。&lt;strong&gt;研究生联赛&lt;/strong&gt;，同样是半场，按照历史成绩，我们还算是传统强队，加上今年阵容确实不错，小组赛踢的基本上比较顺利，不过却没有出线。小组赛最后一场的对手来找我们踢默契球，可以携手出线，因为赛程很紧，基本上是背靠背在打，大家商量也觉得没什么，就答应了。结果惹怒了老师，没有能够出线。以至于为此郁闷了很久，因为我本可以按照自己的想法，拒绝这样踢。其实那场比赛踢的比平常都要累，节奏把握不好，而且根本感觉不到踢球比赛的乐趣。下一届比赛，一定要好好踢。&lt;strong&gt;院赛&lt;/strong&gt;，自己院的比赛，研究生组了一队，拿到了冠军。都是熟人，比较好玩。&lt;strong&gt;振兴杯&lt;/strong&gt;，学校足球最高级别的比赛，大家都很重视，甚至暑假的时候就在商量阵型，名单安排等等。每周训练啊，至少一场热身赛啊，赛前开会动员啊，还是挺正式的。从边后卫改成了后腰。正式比赛前一天晚上，本科球队来武汉玩，约了一场夜场，真是两者不可兼顾，夜场只提了半场，很不尽兴啊。不过第二天振兴杯有一个助攻，一个进球。哈哈，提了这么多年，这还是第一次在学校正式比赛进球。不知道算不算是弥补了本科最后一场打丢可以让球队出线的进球。淘汰赛第一场就碰到经常一起踢野球的小伙伴他们院，领先，被扳平，被反超，结束前扳平，点球获胜，真是惊心动魄。然后遇到这届比赛的冠军队，被虐的不行，确实是实力差距啊。八强也是平了历史最好成绩，第一次参赛也还满意。后面赛后结束出去聚餐，很巧的碰到淘汰赛第一场的对手他们，开始还有点尴尬，后来一起对着喝，我才知道小伙伴他们输了比赛后都哭了，因为是最后一届。足球确实值得让男生痛哭，怎么会不懂。不得不承认，武大的比赛真是不少，以前在中南都是跑去踢野球，来了武大训练+比赛，基本就够啊。附一张比赛照（还是对手照的，哈哈）：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/img/uploads/2016/01/zj4.png&quot;&gt;&lt;img src=&quot;/img/uploads/2016/01/zj4.png&quot; alt=&quot;zj4&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;除了学校的比赛，本科队友虽然都不在一个地方了，还是抑制不住我们一起踢球的欲望。清明大家齐聚上海，在外滩坐轮船兜了一圈，看个电影，睡个懒觉，就准备在上交踢比赛了！客场作战人员不是很够，上半场被进了两个，不过我们还是有实力的，下半场就扳回来了。虽然没有赢，不过也没有输啊，晚上大伙还是高高兴兴吃烧烤，自然又喝的不省人事了。国庆去了西安，终于回到老家了，不过规模比较小，本来主要是旅游的，结果还是到陕师大，西交大踢了两次。陕师大我们几个穿着牛仔裤，开始被人鄙视不加，让我们和几个小学生玩，后来加上和他们踢，被我们虐的不要不要的，有一种大隐隐于牛仔裤的感觉。去西交大前一天爬了华山，还有点感冒，不过该踢还是要踢起，没想到第一次进西交大就差点和别人打起来，怎么说都是我高中的理想大学啊。碰到了一群大人，素质略低，然后就换了一边人踢。踢的很激烈，到最后都抽筋了，不过进了三个球，感冒瞬间好了很多，晚上当然又去腐败了。最近的一次是在武汉，不是什么节日，一个队友跳槽了，有几天空闲，就搞起了。约了一个夜场，上半场还是挺焦灼的，不过下半场我一下，就开始虐对面，此时应该感谢组织带我飞。虽然大家都毕业了，每次也没有什么计划，基本上都是前一两天决定去，然后一个人喊，大家就开始订票，结束一次就想着下一次去哪。人只要在，到哪和谁踢都不怕，从大二建队开始到处被虐，到现在已经不记得上次输是什么时候了。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/img/uploads/2016/01/zj5.png&quot;&gt;&lt;img src=&quot;/img/uploads/2016/01/zj5.png&quot; alt=&quot;zj5&quot; /&gt;&lt;/a&gt;&lt;a href=&quot;/img/uploads/2016/01/zj6.png&quot;&gt;&lt;img src=&quot;/img/uploads/2016/01/zj6.png&quot; alt=&quot;zj6&quot; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;life&quot;&gt;Life&lt;/h3&gt;

&lt;p&gt;这一年也有很多波折，经历了亲人的离去，家里新成员的诞生，悲欢离合也都过了一遍。遇到了很多好事，觉得生活充满希望，前途一片光明，也有低落的时候，一片光明，却发现没有出路。体会最深的是，无论什么事，只靠想是不行，试过才知道。与其后悔这件事没做，那件事没做，不过说这件事做好了，那件事没做好。畅想一下明年吧，把DPINM做好；小论文要早点发；找个搞数据库的工作；去实习赚点毕业旅行的钱；考驾照；翻译一份BDB资料；研究生联赛好好踢；blablabla….&lt;/p&gt;

&lt;p&gt;新年好&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/img/uploads/2016/01/zj7.png&quot;&gt;&lt;img src=&quot;/img/uploads/2016/01/zj7.png&quot; alt=&quot;zj7&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 01 Jan 2016 16:15:57 +0800</pubDate>
        <link>http://localhost:4000/life%20traces/2016/01/01/e5-86-8d-e8-a7-812015/</link>
        <guid isPermaLink="true">http://localhost:4000/life%20traces/2016/01/01/e5-86-8d-e8-a7-812015/</guid>
        
        <category>年终总结</category>
        
        
        <category>life traces</category>
        
      </item>
    
      <item>
        <title>暗时间</title>
        <description>&lt;p&gt;本文转自&lt;strong&gt;&lt;a href=&quot;http://mindhacks.cn/2009/12/20/dark-time/&quot;&gt;Mind Hack&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Mind Hack 这个博客前两年就看到了，虽然文章数量不多，可以说是我看过最好的博客，甚至在建自己博客站点的时候用的都是相同的主题。其中除了计算机技术方面的文章，其它思维方式的文章真的会有一种 Mind 被 Hack 的感觉。最近干活效率很低，同样生活效率也低，不仅收获很少，而且并不开心。特转其中一篇重读，抓住时间。&lt;/p&gt;

&lt;p&gt;正文：&lt;/p&gt;

&lt;p&gt;如果你有一台计算机，你装了一个系统之后就整天把它搁置在那里，你觉得这台计算机被实际使用了吗？没有。因为CPU整天运行的就是空闲进程。运行空闲进程也是一天，运行大数据量计算的程序也是一天，对于CPU来说同样的一天，价值却是完全不一样的。&lt;/p&gt;

&lt;p&gt;大脑也是如此。&lt;/p&gt;

&lt;p&gt;善于利用思维时间的人，可以无形中比别人多出很多时间，从而实际意义上能比别人多活很多年。我们经常听说“心理年龄”这个词，思考得多的人，往往心理年龄更大。有人用10年才能领悟一个道理，因为他们是被动领悟——只有在现实撞到他脸上的时候才感到疼，疼完了之后还是不记得时时提醒自己，结果很快时过境迁抛之脑后，等到第二次遇到同一个坑的时候早忘了曾经跌过跟头了，像这样的效率，除非天天摔坑里，否则遗忘的效率总是大过吃亏长的记性。善于利用思维时间的人则能够在重要的事情上时时主动提醒自己，将临时的记忆变成硬编码的行为习惯。&lt;/p&gt;

&lt;p&gt;每个人的手表都走得一样快，但每个人的生命却不是。衡量一个人生活了多少年，应该用思维时间来计算。举一个极端的例子，如果一个人从生下来开始就呆在一个为他特殊建造的无菌保护室里，没有社会交往，没有知识获取，度过了18年，你会不会认为他成年了？&lt;/p&gt;

&lt;p&gt;认为时间对每个人是均等的是一个错觉，认为别人有一天，我也有一天，其实根本不是这样。如果你正在学习一门专业，你使用自己所投入的天数来衡量，很容易会产生一种错觉，认为投入了不少时间，然而其实，“投入时间”这个说法本身就是荒唐的，实际投入的是时间和效率的乘积。你可以“投入”很多时间在一件事情上面，却发现毫无进展，因为你没有整天把你要做的事情，要学习的东西常驻在你的大脑中，时刻给予它最高的优先级。你走路的时候吃饭的时候，做梦的时候心心念念想的就是这件事情，你的CPU总是分配给它，这个时候你的思维时间就被利用到了极致，你投入的时间就真正等于了实际流逝的时间，因为你的CPU是满载的。&lt;/p&gt;

&lt;p&gt;如果你有做总结的习惯，你在度过一段时间之后总结自己在某某领域投入了多少时间，建议千万不要粗略地去计算有多少天下班后拿起书来翻看过，因为这样你也许会发现书倒是常翻，但领悟却不见得多深，表面上花的时间不少，收益却不见得那么大。因为看书并记住书中的东西只是记忆，并没有涉及推理，只有靠推理才能深入理解一个事物，看到别人看不到的地方，这部分推理的过程就是你的思维时间，也是人一生中占据一个显著比例的“&lt;strong&gt;暗时间&lt;/strong&gt;”，你走路、买菜、洗脸洗手、坐公车、逛街、出游、吃饭、睡觉，所有这些时间都可以成为“暗时间”，你可以充分利用这些时间进行思考，反刍和消化平时看和读的东西，让你的认识能够脱离照本宣科的层面。这段时间看起来微不足道，但日积月累将会产生庞大的效应。&lt;/p&gt;

&lt;p&gt;能够充分利用暗时间的人将无形中多出一大块生命，你也许会发现这样的人似乎玩得不比你少，看得不比你多，但不知怎么的就是比你走得更远。比如我就经常发现一些国外的牛人们为什么不仅学习牛逼，连“业余”玩儿的东东也都搞得特牛逼，一点都不业余（上次在&lt;a href=&quot;http://www.douban.com/subject/3440613/&quot;&gt;《How We Decide》&lt;/a&gt;上看到&lt;a href=&quot;http://en.wikipedia.org/wiki/Michael_Binger&quot;&gt;斯坦福的一个牛人&lt;/a&gt;，理论物理学博士，同时是世界扑克大赛的前六名保持者，迄今累计奖金拿了六百多万刀），你会奇怪，&lt;strong&gt;这些家伙到底哪来的时间，居然可以在不止一个领域做到卓越&lt;/strong&gt;？&lt;/p&gt;

&lt;p&gt;程序员们都知道，任务切换需要耗费许多额外的花销，通俗地来讲，首先需要保存当前上下文以便下次能够顺利切换回来，然后要加载目标任务的上下文。如果一个系统不停地在多个任务之间来回倒腾，就会耗费大量的时间在上下文切换上，无形中浪费很多的时间。&lt;/p&gt;

&lt;p&gt;相比之下，如果只做一件任务，就不会有此损失。这就是为什么专注的人比不专注的人时间利用效率高得多的原因。任务切换的暗时间看似非常不明显，甚至很多人认为“多任务”是件很好的事情（有时候的确是），但日积月累起来就会发现，消耗在切换上的时间越来越多。&lt;/p&gt;

&lt;p&gt;另外，大脑开始一件任务的时候必须要有一定时间来“热身”，这个时间因人而异，并且可以通过练习来改变。举个例子，你看了一会书之后，忽然感到一阵无聊，忍不住打开浏览器，十分钟后你想起来还要继续看书，但要回复到当时理想的状态，却需要一段时间来努力去集中精力，把记忆中相关的知识全都激活起来，从而才能进入“状态”，因为你上了十分钟网之后这些记忆已经被抑制了。如果这个“热身”状态需要一刻钟，那么看似十分钟的上网闲逛其实就花费了二十五分钟。&lt;/p&gt;

&lt;p&gt;如果阅读的例子还不够生动，对于程序员来说其实有更好的例子：你写程序写得正high，忽然被叫去开了一通会，写到一半的代码搁在那儿。等你开完会回来你需要多久能够重新进入状态？又或者，你正在调试程序，你已经花了二十分钟的时间把与这个bug可能相关的代码前前后后都理解了一遍，心中构建了一个大致的地图，就在这时，呃，你又被叫去开了个会(:D)，开完会回来，可想而知，得花上一些时间来回想一下刚刚弄清的东西了。&lt;/p&gt;

&lt;p&gt;迅速进入状态的能力是可以锻炼的，根据我个人的经验，至少可以缩短到3-5分钟。但要想完全进入状态，却是很难在这么短的时间实现的。所谓完全进入状态，举个例子：你看了3个小时的书，或者调试了半个小时的程序之后，往往满脑子都是相关的东西，所有这些知识都处在活跃状态，换言之你大脑中所有相关的记忆神经网络都被激活了，要达到这样一种忘记时间流逝的“沉浸”状态（心理学上叫做“&lt;a href=&quot;http://en.wikipedia.org/wiki/Flow_%28psychology%29&quot;&gt;流体验&lt;/a&gt;”），不是三两分钟的事情。而一旦这种状态被破坏，无形间效率就会大打折扣。这也是为什么我总是倾向于创造大块的时间来阅读重要的东西，因为这样有利于“沉浸”进去，使得新知识可以和大脑中与其相关的各种既有的知识充分融合，关联起来，&lt;a href=&quot;http://mindhacks.cn/2009/03/28/effective-learning-and-memorization/&quot;&gt;后者对于深刻的记忆非常有帮助&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;要充分利用暗时间，不仅要能够迅速进入状态，另一个很重要的习惯就是能够保持状态多久（&lt;a href=&quot;http://www.douban.com/subject/1867455/&quot;&gt;思维体力&lt;/a&gt;）。《&lt;a href=&quot;http://www.douban.com/subject/1770012/&quot;&gt;The Psychology of Invention in the Mathematical Field&lt;/a&gt;》上有一段关于庞加莱的思考习惯的介绍，很有代表性。庞加莱经常在去海边休假或者在路上走的时候在脑海中思索数学问题，很多时候解答就在这些时候忽然闪现。虽然我和庞加莱是没法比的，但是常常也在路上想出答案，这真是一种愉悦的体验。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;能够迅速进入专注状态，以及能够长期保持专注状态，是高效学习的两个最重要习惯。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;很多人都有这样的体验（包括我自己），工作了之后，要处理的事情一下多出了很多，不像在校园，环境简单，生活单纯，能够心无旁骛地做一件事情而不被打扰。工作之后的状况就是，首先需要处理的事情变多，导致时不时需要在多个任务之间切换；另一方面，即便能够把任务的优先级分配得比较合理，也难免在做一件事情的时候心中忽然想起另一件事还没做的焦虑来，因为没做完的事情会在大脑中留下一个“隐藏的进程”，时不时地发个消息提醒你一下，中断你正在做的事情。&lt;/p&gt;

&lt;p&gt;因此这里就涉及到最后一个高效的习惯：抗干扰。只有具备超强的抗干扰能力，才能有效地利用起前面提到的种种暗时间。抗干扰能力也是可以练习出来的，上本科那会经常坐车，所以我就常常拿着本大部头在车上看，坐着看或者站着看都可，事实证明在有干扰的环境中看书是非常锻炼专注能力的一个办法:D 另外，经常利用各种碎片时间阅读和思考，对迅速集中注意力和保持注意力都非常有帮助。记得很久以前TopLanguage上大伙曾经有次饶有兴趣地讨论&lt;a href=&quot;http://groups.google.com/group/pongba/browse_thread/thread/388640d8d07f81f/&quot;&gt;“马桶时间”的利用&lt;/a&gt;，包括&lt;a href=&quot;http://groups.google.com/group/pongba/msg/2ba79504a3062a10&quot;&gt;在卫生间放个小书柜&lt;/a&gt;。（估计很多同学心有戚戚焉吧:D）&lt;/p&gt;

&lt;p&gt;后：&lt;/p&gt;

&lt;p&gt;这篇文章从提高效率的角度讲了“暗时间”，如果从另一个方面来考虑，选择所做的事也可以增加效率。这里的效率也许不仅仅是对一件事，而是对于一个人而言。如果相同的时间，相同的投入，相同的专注只去做类似的事，实际上也是低效的。比如每天放松都会看两集电视剧，看完甄嬛传看芈月传，看完国产看美剧。如果相同的时间，去试着跑步，学一种运动等，就会丰富很多，整个人的”效率“是不是有所提高呢？这种思维好像和”多而不专“相互冲突，可以参考上文”&lt;a href=&quot;http://en.wikipedia.org/wiki/Michael_Binger&quot;&gt;斯坦福的一个牛人&lt;/a&gt;“。假设这个人效率奇高，应付博士学位绰绰有余，但空下来的时间没有去尝试打扑克，怎么会成为扑克高手？如果所做的事充满乐趣，就不会放弃去做其它的，但如果所做的事非常熟悉，不悲不喜，不如去做更多没有做过的事。（又让我想起了小学看过的一本薄薄的书，”&lt;a href=&quot;http://book.douban.com/subject/4722180/&quot;&gt;&lt;strong&gt;谁动了我的奶酪&lt;/strong&gt;&lt;/a&gt;“）&lt;/p&gt;
</description>
        <pubDate>Wed, 09 Dec 2015 22:23:34 +0800</pubDate>
        <link>http://localhost:4000/life%20traces/reprinted%20articles/2015/12/09/499/</link>
        <guid isPermaLink="true">http://localhost:4000/life%20traces/reprinted%20articles/2015/12/09/499/</guid>
        
        <category>Thinking</category>
        
        
        <category>life traces</category>
        
        <category>reprinted articles</category>
        
      </item>
    
  </channel>
</rss>
