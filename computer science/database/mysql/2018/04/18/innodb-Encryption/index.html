<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="life test">
    <meta name="keywords"  content="mysql">
    <meta name="theme-color" content="#000000">

    <title>InnoDB 表空间加密 - 张小贱的博客 | Zhangxiaojian Blog</title>

    <!-- Web App Manifest -->
    <link rel="manifest" href="/pwa/manifest.json">

    <!-- Favicon -->
    <link rel="shortcut icon" href="/img/favicon.ico">
    
    <!-- Canonical URL -->
    <link rel="canonical" href="http://localhost:4000/computer%20science/database/mysql/2018/04/18/innodb-Encryption/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/hux-blog.min.css">

    <!-- Pygments Github CSS -->
    <link rel="stylesheet" href="/css/syntax.css">

    <!-- Custom Fonts -->
    <!-- <link href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- Hux Delete, sad but pending in China
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
    css'>
    -->


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">

    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">张小贱</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>
                    
                    <li>
                        <a href="/about/">About</a>
                    </li>
                    
                    <li>
                        <a href="/tags/">Tags</a>
                    </li>
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>

<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    var __HuxNav__ = {
        close: function(){
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        },
        open: function(){
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }

    // Bind Event
    $toggle.addEventListener('click', function(e){
        if ($navbar.className.indexOf('in') > 0) {
            __HuxNav__.close()
        }else{
            __HuxNav__.open()
        }
    })

    /**
     * Since Fastclick is used to delegate 'touchstart' globally
     * to hack 300ms delay in iOS by performing a fake 'click',
     * Using 'e.stopPropagation' to stop 'touchstart' event from 
     * $toggle/$collapse will break global delegation.
     * 
     * Instead, we use a 'e.target' filter to prevent handler
     * added to document close HuxNav.  
     *
     * Also, we use 'click' instead of 'touchstart' as compromise
     */
    document.addEventListener('click', function(e){
        if(e.target == $toggle) return;
        if(e.target.className == 'icon-bar') return;
        __HuxNav__.close();
    })
</script>


    <!-- Image to hack wechat -->
<!-- <img src="/img/icon_wechat.png" width="0" height="0"> -->
<!-- <img src="/img/home-bg-o.jpg" width="0" height="0"> -->

<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        position: relative;
        background-image: url('/img/home-bg-o.jpg')
    }

    
</style>
<header class="intro-header" >
    <div class="header-mask"></div>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        
                    </div>
                    <h1>InnoDB 表空间加密</h1>
                    
                    
                    <h2 class="subheading"></h2>
                    
                    <span class="meta">Posted by zhangxiaojian on April 18, 2018</span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

    <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <!-- Multi-Lingual -->
                

				<h2 id="背景简介">背景简介</h2>

<p>InnoDB 表空间加密是在引擎内部数据页级别的加密手段，在数据页写入文件系统时加密，从文件读到内存中时解密，目前广泛使用的是 YaSSL/OpenSSL 提供的 <a href="https://en.wikipedia.org/wiki/Advanced_Encryption_Standard">AES</a> 加密算法，加密前后数据页大小不变，因此也称为透明加密。表空间加密相对于文件系统加密更加灵活，用户可以控制加密重要的表，防止被拖库导致的数据丢失。MySQL 官方在 <a href="https://dev.mysql.com/doc/relnotes/mysql/5.7/en/news-5-7-11.html">5.7.11</a> 中发布了表空间加密功能，Aliyun RDS 差不多在同时支持了 RDS MySQL 版的表空间加密，通过了<a href="https://www.aliyun.com/product/rds/mysql?spm=5176.8142029.388261.312.e9396d3eOfI3U5">“等保三级”</a> 的认证，随后 MariaDB 在 10.1 支持了功能增强版的“表空间加密”，除了表空间，还可以对 Redo log 和 Binlog 进行加密，参考<a href="https://mariadb.com/resources/blog/table-and-tablespace-encryption-mariadb-101">这篇</a>详细介绍。本文将详细介绍官方的实现方式。</p>

<h2 id="keyring-plugin">Keyring Plugin</h2>

<p>Keyring Plugin 是用来保存敏感信息的插件，目前官方支持了四种插件: <a href="https://dev.mysql.com/doc/refman/5.7/en/keyring-file-plugin.html">keyring_file</a>, <a href="https://dev.mysql.com/doc/refman/5.7/en/keyring-encrypted-file-plugin.html">keyring_encrypted_file</a>, <a href="https://dev.mysql.com/doc/refman/5.7/en/keyring-okv-plugin.html">keyring_okv</a>, <a href="https://dev.mysql.com/doc/refman/5.7/en/keyring-aws-plugin.html">keyring_aws</a>, 社区版目前只支持 keyring_file 类型，本文基于此类型介绍。</p>

<p>如果要使用表空间加密功能，keyring_file 必须在 MySQL 实例初始化之前初始化(使用 –early-plugin-load 参数)，因为 keyring_file 里面保存了解密需要的 master_key。我们可以把这个插件理解成一个 K-V 表，可以根据 key 查找到对应的数据。在源码内部提供了以下几个接口：</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* 根据 key_id 查找秘钥 */</span>
<span class="n">STRING</span> <span class="n">keyring_key_fetch</span><span class="p">(</span><span class="n">STRING</span> <span class="n">key_id</span><span class="p">);</span>

<span class="cm">/* 以 key_id 生成加密类型为 key_type 长度为 key_length 的秘钥，并存储到文件中 */</span>
<span class="n">STRING</span> <span class="n">keyring_key_generate</span><span class="p">(</span><span class="n">STRING</span> <span class="n">key_id</span><span class="p">,</span> <span class="n">STRING</span> <span class="n">key_type</span><span class="p">,</span> <span class="n">INTEGER</span> <span class="n">key_length</span><span class="p">);</span>

<span class="cm">/* 返回秘钥长度 */</span>
<span class="n">INTEGER</span> <span class="n">keyring_key_length_fetch</span><span class="p">(</span><span class="n">STRING</span> <span class="n">key_id</span><span class="p">);</span>

<span class="cm">/* 移除秘钥 */</span>
<span class="n">INTEGER</span> <span class="n">keyring_key_remove</span><span class="p">(</span><span class="n">STRING</span> <span class="n">key_id</span><span class="p">);</span>

<span class="cm">/* 混淆并且存储秘钥 */</span>
<span class="n">INTEGER</span> <span class="n">keyring_key_store</span><span class="p">(</span><span class="n">STRING</span> <span class="n">key_id</span><span class="p">,</span> <span class="n">STRING</span> <span class="n">key_type</span><span class="p">,</span> <span class="n">STRING</span> <span class="n">key</span><span class="p">);</span>

<span class="cm">/* 返回秘钥加密类型 */</span>
<span class="n">STRING</span> <span class="n">keyring_key_type_fetch</span><span class="p">(</span><span class="n">STRING</span> <span class="n">key_id</span><span class="p">);</span>
</code></pre></div></div>

<p>用户可以创建 UDF(User Deifined Function) 在 SQL 语句中使用上述接口，作为独立于表空间加密的功能使用，具体使用方式可以参考：<a href="https://dev.mysql.com/doc/refman/5.7/en/keyring-udfs-general-purpose.html">General-Purpose Keyring Key_Management Functions</a>。把 keyring_file 放到本地文件显然是不安全的，建议放到类似U盘的地方，启动实例的时候挂载到文件系统，启动之后移除，大概就像原来银行的优盾 ：）</p>

<h2 id="流程分析">流程分析</h2>

<h3 id="整体架构">整体架构</h3>
<p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/24d947b261fdb30a2d4555c3b2af2a99.png" alt="encrypt1.png" /></p>

<p>为了支持 key rotation，官方的加密用到了两个秘钥，一个是从 kering 生成的 master_key，另一个是用来加密每个表空间的 tablespace_key，master_key 仅仅用来加密解密 tablespace_key。tablespace_key 加密后保存在每个 ibd 文件 page 0 页的尾部，对应图中 Encryption Information 部分，除了 tablespace_key, 还有用来索引 master_key 的 master_key_id 信息，以及 magicnum 和循环冗余校验的数据。关于 InnoDB ibd 文件的页面组织可以参考月报<a href="http://mysql.taobao.org/monthly/2016/02/01/">InnoDB 文件系统之文件物理结构</a>,首个页空间利用并不满。</p>

<p>在 server 层，创建一个加密的表后，加密的信息会保存在 frm 文件中，主要作用是 show create table 时可以打印出加密部分的语句。</p>

<p>InnoDB 层除了 Encryption Information，还会在 ibdata 的字典表中的 flags2 字段标识对应的表示加密表，具体存储在 SYS_TABLES 表 MIX_LEN  列中，关于 InnoDB 字典表结构可以参考<a href="https://twindb.com/innodb-dictionary/">这篇文章</a>。在 ibd 文件中会在 page 0 页头部 FSP 的 FLAG 标识这个 File Space 是加密表空间，具体位置在 FSP_FLAGS_POS_ENCRYPTION，如图中 Encryption 所示位置。还会在每个 Index page 的 page type 位置标识这个页是加密的，对应图中 page type 位置。</p>

<blockquote>
  <p>Note: 在 ibdata 中的系统表空间，比如 redo，undo 等是默认不加密的，ibd 文件 page 0 也是不加密的，Index page 只会对数据部分加密，Page Header 不会被加密。</p>
</blockquote>

<p>上述部分是整体架构和物理文件页面有哪些变化，相对于 MySQL 5.6 使用了一些预留的标记为空间，迁移的话保证对应的位置不会冲突。</p>

<h3 id="代码分析">代码分析</h3>

<h4 id="基础类介绍">基础类介绍</h4>
<p>MySQL 5.7 的代码相对于 5.6 版本有了较大的重构，主要是把之前面向过程的代码更多的用类结构封装。表空间加密主要交互是在和文件的 IO 交互，页写入文件之前加密，从文件读出第一时间解密。还有一个 Encryption 类，负责调用 keyring plugin 来维护 master_key, 保存 tablespace key 加密的时候用，还提供页面的加密解密函数等。代码重构后 IO 部分使用类 IORequest 类来控制具体 IO 的行为，比如是 READ 还是 WRITE，是否是对 LOG 的 IO, 是否加密，是否压缩等等。如下类图所示，Encryption 类注入到 IORequest 中。</p>

<p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/94a73bfd92d494e3c9d2c03ab45e753e.png" alt="encrypt2.png" /></p>

<p>下面首先介绍一下 master_key 的维护，Encryption 类中有两个静态成员变量，master_key_id 是一个递增的值，每次生成新的 master_key 都会更新，uuid 是当前的 server_uuid。 前面介绍了 keyring plugin 提供的接口函数，在 create_master_key, get_master_key * 2, 三个静态函数中调用。对应 keyring plugin 的 key_id 参数，是 [ENCRYPTION_MASTER_KEY_PRIFIX+uuid+master_key_id] 的字符串组合，用变量 key_name 表示。create_master_key 获得一个新的 master_key:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">create_master_key</span>
      <span class="o">|</span>
      <span class="o">----</span> <span class="n">my_key_generate</span><span class="p">(</span><span class="n">key_name</span><span class="p">,</span> <span class="s">"AES"</span><span class="p">,</span> <span class="n">ENCRYPTION_KEY_LEN</span><span class="p">)</span>
      <span class="o">|</span>
      <span class="o">----</span> <span class="n">my_key_fetch</span><span class="p">(</span><span class="n">key_name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">keytype</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">master_key</span><span class="p">,</span> <span class="n">key_len</span><span class="p">)</span>
</code></pre></div></div>

<p>get_master_key 是一个重载函数，因为历史原因，为了兼容 5.7.11 版本最初设计的加密格式，需要 uuid 作为一个检索的参数，图中第一个 get_master_key 函数根据传入的参数调用 my_key_fetch 查找，第二个函数的参数都是指针类型，返回之后都会被赋值，如果发现当前的 Encryption::master_key_id 为 0，说明还没有产生过 master_key ，就执行类似 create_master_key 的逻辑创建。</p>

<p>接下来看加密和解密的函数，参数类似，就是传入一个 src 页，然后加密好放到 dst 页中，数据页加密使用的加密算法是 <a href="https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation">my_aes_256_cbc</a>,这种加密算法要求每个加密块大小是 128 bit(16 Byte)，也就是说数据页的大小必须是这个值得整数倍，InnoDB 的页默认大小是 16K，传入整个页进行加密是完全可行的。但是官方选择了最小加密原则，仅仅只对页面中用户数据部分加密，页面头保持明文存储。所以无论是加密还是解密都分成了两次调用，一次对 main_len 大小数据加密，另外一次对 remain_len 加密：</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">data_len</span> <span class="o">=</span> <span class="n">src_len</span> <span class="o">-</span> <span class="n">FIL_PAGE_DATA</span><span class="p">;</span>
<span class="n">main_Len</span> <span class="o">=</span> <span class="p">(</span><span class="n">data_len</span> <span class="o">/</span> <span class="n">MY_AES_BLOCK_SIZE</span><span class="p">)</span> <span class="o">*</span> <span class="n">MY_AES_BLOCK_SIZE</span><span class="p">;</span>
<span class="n">remain_len</span> <span class="o">=</span> <span class="n">data_len</span> <span class="o">-</span> <span class="n">main_len</span><span class="p">;</span>
</code></pre></div></div>
<p>加密部分会修改页面的 page type 字段，从 src 页固定位置取出当前的页类型，如果是加密过的，就报错，加密结束之后根据原有的页面类型，修改为对应的加密页类型：</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">page_type</span> <span class="o">==</span> <span class="n">FIL_PAGE_COMPRESSED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mach_write_to_2</span><span class="p">(</span><span class="n">dst</span> <span class="o">+</span> <span class="n">FIL_PAGE_TYPE</span><span class="p">,</span>
		<span class="n">FIL_PAGE_COMPRESSED_AND_ENCRYPTED</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">page_type</span> <span class="o">==</span> <span class="n">FIL_PAGE_RTREE</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* If the page is R-tree page, we need to save original
		type. */</span>
		<span class="n">mach_write_to_2</span><span class="p">(</span><span class="n">dst</span> <span class="o">+</span> <span class="n">FIL_PAGE_TYPE</span><span class="p">,</span> <span class="n">FIL_PAGE_ENCRYPTED_RTREE</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span><span class="p">{</span>
		<span class="n">mach_write_to_2</span><span class="p">(</span><span class="n">dst</span> <span class="o">+</span> <span class="n">FIL_PAGE_TYPE</span><span class="p">,</span> <span class="n">FIL_PAGE_ENCRYPTED</span><span class="p">);</span>
		<span class="n">mach_write_to_2</span><span class="p">(</span><span class="n">dst</span> <span class="o">+</span> <span class="n">FIL_PAGE_ORIGINAL_TYPE_V1</span><span class="p">,</span> <span class="n">page_type</span><span class="p">);</span>
	<span class="p">}</span>
</code></pre></div></div>

<p>其中 R-tree 是 MySQL 为了支持 GIS 引入的数据类型。<a href="https://dev.mysql.com/worklog/task/?id=6968">WL#6968</a>.解密开始会判断 page type 是否是压缩类型，需要修改src_len 的大小。</p>

<h4 id="tablespace-key-初始化和读取">Tablespace key 初始化和读取</h4>
<p>Tablespace key 是真正用来加密用户页面数据的，就是上节介绍的 Encryption 类的 m_key，tablespace key 会在 create 一个加密表或者 alter 一个表变为加密表时创建，以 create table 流程为例，因为只支持独立表空间，所以需要递增的产生一个 space id，然后创建一个 ibd 文件，并且初始化为默认的 page 数量大小，把 space id 和 fsp flags 写入第一个页的头部（fsp flags 对应整体架构图中 Encryption 部分，标记一个表空间为加密表空间，flags 由 dict_table_t 结构的 flag 转化而来，而 dict_table_t 的 flag 是从 server 层的 TABLE_SHARE 中获得，源头就是用户执行的 create table 语句语法）， 创建 file_space_t，初始化 file_node(虽然表空间只有一个 ibd 文件)，接着调用 fil_set_encryption 函数生成 tablespace key，并且保存在刚刚创建的 fil_space_t 中。最终会在 fsp_head_init 函数中把 tablespace key 相关信息写入页面中，对应整体架构图中 Encryption Infomation 部分。函数调用栈：</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">dict_build_tablespace</span>
      <span class="o">|</span>
      <span class="o">---</span> <span class="n">fil_ibd_create</span>
      <span class="o">|</span>	    <span class="o">|</span>
      <span class="o">|</span>	    <span class="o">---</span> <span class="n">os_fil_create</span>
      <span class="o">|</span>	    <span class="o">|</span>
      <span class="o">|</span>	    <span class="o">---</span> <span class="n">os_file_set_size</span>
      <span class="o">|</span>	    <span class="o">|</span>
      <span class="o">|</span>	    <span class="o">---</span> <span class="n">fsp_header_init_fields</span>
      <span class="o">|</span>     <span class="o">|</span>
      <span class="o">|</span>     <span class="o">---</span> <span class="n">os_file_write</span>
      <span class="o">|</span>     <span class="o">|</span>
      <span class="o">|</span>     <span class="o">---</span> <span class="n">file_space_create</span>
      <span class="o">|</span>     <span class="o">|</span>
      <span class="o">|</span>     <span class="o">---</span> <span class="n">fil_set_encryption</span><span class="p">(</span><span class="n">space_id</span><span class="p">,</span> <span class="n">Encryption</span><span class="o">::</span><span class="n">AES</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span>
      <span class="o">|</span>
      <span class="o">---</span> <span class="n">fsp_header_init</span>
            <span class="o">|</span>
            <span class="o">---</span> <span class="n">fsp_header_fill_encryption_info</span>
            <span class="o">|</span>
            <span class="o">---</span> <span class="n">mlog_write_string</span>
</code></pre></div></div>

<p>重点看一下 fil_set_encryption 是怎么生成 tablespace key 的，还有具体保存在页面中都有哪些东西。上图调用栈最后两个参数为 NULL，对应的就是需要生成的 tablespace key 和加密向量 iv，因为是表空间刚刚创建，NULL 表示需要生成。首先判断是不是系统表空间 is_system_tablespace(space_id) 对于系统表空间不进行加密处理，如果 key 和 iv 为 NULL， 就调用 Encryption::random_value 产生一个随机的值，对于 key 和 iv 都一样，Encryption::random_value 最终会调用 YaSSL/OpenSSL 的 RAND_bytes 函数产生随机值，如果 key 和 iv 不为 NULL，就不必产生，最终赋值到 fil_space_t 中变量即可返回。</p>

<p>真正把 tablespace 加密并且写入到页中的是函数 fsp_header_fill_encryption_info, 从 Encryption::get_master_key 拿到加密的 master_key，从 fil_space_t 中拿到明文的 tablespace key 和 iv，使用 my_aes_256_ecb 加密算法进行加密，ecb 加密算法相对于 cbc 具有更高的安全度，当前开销也更大，看来官方也意识到把 tablespace key 放到文件里存在一定的安全隐患。存储的格式分为两种，是高版本为了向下兼容：</p>

<ul>
  <li>ENCRYPTION_INFO_V1: magic number + master_key_id + key + iv + checksum</li>
  <li>ENCRYPTION_INFO_V1: magic number + master_key_id + key + iv + server_uuid + checksum</li>
</ul>

<p>上述除了 key + iv 之外都是明文存储，checksum 是 key+iv 的明文使用<a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check">32位循环冗余校验</a>得到的。</p>

<p>接下来介绍打开一张已经加密的表，tablespace key/iv 是如何初始化的，直接来看下调用堆栈:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">fil_ibd_open</span>
    <span class="o">|</span>
    <span class="o">---</span> <span class="n">Datafile</span><span class="p">.</span><span class="n">validate_to_add</span>
    <span class="o">|</span>       <span class="o">|</span>
    <span class="o">|</span>       <span class="o">---</span> <span class="n">Datafile</span><span class="o">::</span><span class="n">validate_first_page</span>
    <span class="o">|</span>               <span class="o">|</span>
    <span class="o">|</span>               <span class="o">---</span> <span class="n">fsp_header_get_encryption_key</span>
    <span class="o">|</span>                           <span class="o">|</span>
    <span class="o">|</span>                           <span class="o">---</span> <span class="n">fsp_header_get_encryption_offset</span>
    <span class="o">|</span>                                        <span class="o">|</span>
    <span class="o">|</span>                                        <span class="o">---</span> <span class="n">fsp_header_decode_encryption_info</span>
    <span class="o">|</span>
    <span class="o">---</span> <span class="n">fil_space_create</span>
    <span class="o">|</span>
    <span class="o">---</span> <span class="n">fil_set_encryption</span>
</code></pre></div></div>

<p>正常打开一张表首先会根据表名去 ibdata 的字典表里查找元数据信息，例如文件路径，dict_table_t 的 flags/flags2 等等，接下来就是调用 fil_ibd_open 打开文件， 并且做一系列的校验，Datafile 是用来维护文件信息的类，在 validate_first_page 中会根据 flag 判断是否加密表空间，如果是的话，就读出第一个页，传给 fsp_header_get_encryption_key 函数，在函数里首先计算偏移，然后交给 fsp_header_decode_encryption_info 对 key/iv 进行解密。fsp_header_decode_encryption_info 首先校验 magic number，然后读出 master_key_id 和 server_uuid，用来查找 master_key, 然后用 master_key 解密 tablespace key 得到明文，最后一步是用明文再做一次循环冗余校验，和保存的 checksum 对比，值是否相同。至此已经得到了正确的 tablespace key。接着创建 fil_space_t 然后把明文的 key/iv 放进去，以备后面 IO 使用。</p>

<h4 id="io-路径解析">IO 路径解析</h4>
<p>InnoDB 的 IO 分为同步 IO 和 异步 IO，同步 IO 调用操作系统的 pwrite/pread 函数，异步 IO 又分为 simulate IO 和 Linux native aio， 关于 IO 的详细介绍可以参考 <a href="http://mysql.taobao.org/monthly/2016/02/02/">InnoDB 文件系统之 IO 系统和内存管理</a>， <a href="http://mysql.taobao.org/monthly/2017/03/01/">InnoDB IO 子系统</a>， <a href="http://mysql.taobao.org/monthly/2017/07/10/">InnoDB 异步 IO 工作流程</a> 三篇月报。这里介绍一些加密是在哪里 IO 路径中的，首先是同步 IO 路径, 以 write 为例，read 类似。在 fil_io 中初始化 IORequest 类中的 encryption 相关信息，根据要读写的 page id, fil_space。</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fil_io</span>
  <span class="o">|</span>
  <span class="o">---</span> <span class="n">fil_io_set_encryption</span>
  <span class="o">|</span>
  <span class="o">---</span> <span class="n">os_file_write</span>
  <span class="o">|</span>       <span class="o">|</span>
  <span class="o">|</span>       <span class="o">---</span> <span class="n">os_file_write_pfs</span>
  <span class="o">|</span>                 <span class="o">|</span>
  <span class="o">|</span>                 <span class="o">---</span> <span class="n">os_file_write_func</span>
  <span class="o">|</span>                           <span class="o">|</span>
  <span class="o">|</span>                           <span class="o">---</span> <span class="n">os_file_write_page</span>
  <span class="o">|</span>                                     <span class="o">|</span>
  <span class="o">|</span>                                     <span class="o">---</span> <span class="n">os_file_pwrite</span>
  <span class="o">|</span>                                             <span class="o">|</span>
  <span class="o">|</span>                                             <span class="o">---</span> <span class="n">os_file_io</span>
  <span class="o">|</span>                                                     <span class="o">|</span>
  <span class="o">|</span>                                                     <span class="o">---</span> <span class="n">os_file_encrypt_page</span>
  <span class="o">|</span>                                                                <span class="o">|</span>
  <span class="o">---</span> <span class="n">os_file_read</span>                                                 <span class="o">---</span> <span class="n">Encryption</span><span class="o">::</span><span class="n">encrypt</span>
            <span class="o">|</span>
            <span class="o">---</span> <span class="p">......</span>
            <span class="o">|</span>
            <span class="o">---</span> <span class="n">os_file_io</span>
                  <span class="o">|</span>
                  <span class="o">---</span> <span class="n">os_file_io_complete</span>
                           <span class="o">|</span>
                           <span class="o">---</span> <span class="n">Encryption</span><span class="o">::</span><span class="n">decrypt</span>
</code></pre></div></div>

<p>异步 IO 无论是 simulate IO 还是 native aio， 都是把请求放到一个 slot 里，由后台异步线程去刷盘, 发起 IO 请求的入口函数是 os_aio_func, 对于同步读写请求（OS_AIO_SYNC），发起请求的线程直接调用os_file_read_func 或者os_file_write_func 去读写文件，然后返回。对于异步请求，用户线程从对应操作类型的任务队列（AIO::select_slot_array）中选取一个slot，将需要读写的信息存储于其中（AIO::reserve_slot）, 对于 write 操作，此时把需要写入的数据进行加密。对于Native AIO（使用linux自带的LIBAIO库），调用函数AIO::linux_dispatch，将IO请求分发给kernel层。</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fil_io</span>
  <span class="o">|</span>
  <span class="o">---</span> <span class="n">fil_io_set_encryption</span>
  <span class="o">|</span>
  <span class="o">---</span><span class="n">os_aio</span>
       <span class="o">|</span>
       <span class="o">---</span> <span class="n">os_aio_func</span>
               <span class="o">|</span>
               <span class="o">---</span> <span class="n">AIO</span><span class="o">::</span><span class="n">reserve_slot</span>
               <span class="o">|</span>        <span class="o">|</span>
               <span class="o">|</span>        <span class="o">---</span> <span class="n">os_file_encrypt_page</span>
               <span class="o">|</span>        <span class="o">|</span>
               <span class="o">|</span>        <span class="o">---</span> <span class="n">Encryption</span><span class="o">::</span><span class="n">encrypt</span>
               <span class="o">|</span>
               <span class="o">---</span> <span class="n">linux_dispatch</span><span class="p">(</span><span class="n">slot</span><span class="p">)</span>
</code></pre></div></div>
<p>处理异步 IO 请求的入口函数是 fil_aio_wait, 对于 Native AIO，调用函数os_aio_linux_handle 获取读写请求。IO线程会反复以500ms（OS_AIO_REAP_TIMEOUT）的超时时间通过io_getevents确认是否有任务已经完成了（LinuxAIOHandler::collect()），如果有读写任务完成，找到已完成任务的slot后，释放对应的槽位,写请求已经加密过，直接写入即可，读请求需要进行解密，调用堆栈如下。</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fil_aio_wait</span>
     <span class="o">|</span>
     <span class="o">---</span> <span class="n">os_aio_linux_handle</span>
                <span class="o">|</span>
                <span class="o">---</span> <span class="n">LinuxAIOHandler</span><span class="o">::</span><span class="n">collect</span>
                            <span class="o">|</span>
                            <span class="o">---</span> <span class="n">io_complete</span>
                                    <span class="o">|</span>
                                    <span class="o">---</span> <span class="n">os_file_io_complete</span>
                                               <span class="o">|</span>
                                               <span class="o">---</span> <span class="n">Encryption</span><span class="o">::</span><span class="n">decrypt</span>
</code></pre></div></div>

<h4 id="master-key-rotation">Master key rotation</h4>
<p>Master_key 对于整个实例加密非常重要，官方加密方法最重要的一个特性就是可以更新 master_key, 因为 tablespace_key 的明文不会变，更新 master_key 之后只需要把 tablespace_key 重新加密写入第一个页中即可。入口是 server 层一个类 Rotate_innodb_master_key::execute 函数，这个类继承 Alter_instance 类，execute 函数会调用 innobase_encryption_key_rotation , 这个函数在引擎初始化（innobase_init）的时候注册到 innobase_hton 中。接着创建一个新的 master_key ，由于明文的 tablesapce key 保存在 fil_space_t 中，无需用原来的 master_key 进行解密。然后 fil_encryption_rotate 遍历 fil_system 中的每一个 fil_space_t ，调用 fsp_header_rotate_encrytion 加密 tablespace_key 并存储。</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Rotate_innodb_master_key</span><span class="o">::</span><span class="n">execute</span>
          <span class="o">|</span>
          <span class="o">---</span> <span class="n">innobase_encryption_key_rotation</span>
                      <span class="o">|</span>
                      <span class="o">---</span> <span class="n">Encryption</span><span class="o">::</span><span class="n">create_master_key</span>
                      <span class="o">|</span>
                      <span class="o">---</span> <span class="n">fil_encryption_rotate</span>
                                  <span class="o">|</span>
                                  <span class="o">---</span> <span class="n">fsp_header_rotate_encryption</span>
                                           <span class="o">|</span>
                                           <span class="o">---</span> <span class="n">fsp_header_fill_encryption_info</span>
                                           <span class="o">|</span>
                                           <span class="o">---</span> <span class="n">mlog_write_string</span>
</code></pre></div></div>

<h4 id="export-import">Export/ Import</h4>
<p>为了支持 Export/Import 加密表，引入了 transfer_key，在 export 的时候随机生成一个 transfer_key， 把现有的 tablespace_key 用 transfer_key 加密，并将两者同时写入 table_name.cfp 的文件中，注意这里 transfer_key 保存的是明文。Import 会读取 transfer_key 用来解密，然后执行正常的 import 操作即可，一旦 import 完成，table_name.cfg 文件会被立刻删除。写 transfer_key 调用栈:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">row_quiesce_write_cfp</span>
        <span class="o">|</span>
        <span class="o">---</span> <span class="n">row_quiesce_write_transafer_key</span>
                  <span class="o">|</span>
                  <span class="o">---</span> <span class="n">Encryption</span><span class="o">::</span><span class="n">random_value</span><span class="p">(</span><span class="n">transfer_key</span><span class="p">)</span>
                  <span class="o">|</span>
                  <span class="o">---</span> <span class="n">my_aes_encrypt</span><span class="p">(</span><span class="n">my_aes_256_ecp</span><span class="p">)</span>
</code></pre></div></div>

<p>import 调用栈：</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">row_import_for_mysql</span>
    <span class="o">|</span>
    <span class="o">---</span> <span class="n">row_import_read_cfg</span>
    <span class="o">|</span>       <span class="o">|</span>
    <span class="o">|</span>       <span class="o">---</span> <span class="n">row_import_read_encryption_data</span>
    <span class="o">|</span>                   <span class="o">|</span>
    <span class="o">|</span>                   <span class="o">---</span> <span class="n">fread</span><span class="p">(</span><span class="n">table_name</span><span class="p">.</span><span class="n">cfp</span><span class="p">)</span>
    <span class="o">|</span>                   <span class="o">|</span>
    <span class="o">|</span>                   <span class="o">---</span> <span class="n">my_aes_decrypt</span>
    <span class="o">|</span>
    <span class="o">---</span> <span class="n">fil_tablespace_iterate</span>
            <span class="o">|</span>
            <span class="o">---</span> <span class="n">fil_iterator</span>
                  <span class="o">|</span>
                  <span class="o">---</span> <span class="n">IORequest</span><span class="o">::</span><span class="n">encryption_key</span>
                  <span class="o">|</span>
                  <span class="o">---</span> <span class="n">os_file_read</span>
                  <span class="o">|</span>
                  <span class="o">---</span> <span class="n">os_file_write</span>
</code></pre></div></div>

<h4 id="崩溃恢复">崩溃恢复</h4>
<p>在数据库进行崩溃恢复的时候 InnoDB 是无法从字典表取得数据的，也就是说正常判断一个表是不是加密表的路径（Dict_table_t::flags2 -&gt; fil_space_t）是行不通的，所以需要在 ibd 文件的头部标记加密，读取 ibd 就知道表空间类型。对于官方的加密方法，因为有 tablespace_key 的相关信息持久化在页面上，受 redo 保护，所以在崩溃恢复的时候需要能够从 redo 中正确解析，需要增加处理逻辑。对于崩溃恢复的详细介绍可以参考早期月报 <a href="http://mysql.taobao.org/monthly/2015/06/01/">Innodb 崩溃恢复过程</a>。这部分相关修改并不多，首先需要构建 recv_sys , 在 recv_sys 结构中增加了一个 encryption_list, 保存需要回复的加密表空间信息, 初始化在 recv_parse_or_apply_log_rec_body 中，如果是 page = 0 的页，并且不是系统表空间，就调用 fil_write_encryption_parse -&gt; fsp_header_decode_encryption_info 进行解析，拿到 master_id, 查找 keyring plugin 得到 master_key, 然后解析 tablespace_key，如果是未加载的表空间，就放到 recv_sys-&gt;encryption_list 里面。</p>

<p>在构建 recv_spaces 的时候，会调用 fil_name_parse-&gt;fil_name_process-&gt;fil_ibd_load ， 如果是加密表空间，并且在 recv_sys-&gt;encryption_list 中，就从 recv_sys-&gt;encryption_list 里找到对应的 space id 初始化加密信息，后面应用 redo 日志就可以先对页面进行加解密处理。</p>

<h3 id="总结">总结</h3>
<p>官方的这种加密方式优点和缺点都相当明显，优点是 master_key 可以经常更新，能够满足一定的用户需求，并且每个表都可以拥有不同的秘钥 tablespace_key ，即使一张表被破解，其它表也不会立刻丢失数据。缺点也在 tablesapce_key 的存放上，所有的人都知道加密的秘钥保存在哪里，甚至知道明文的 checksum 是什么，对于高安全的用户来说，秘钥不落地是非常重要的，显然官方的这种加密方式无法满足。另外一个很危险的就是 export/import ， 虽然重新生成了一个 transfer_key，但是竟然是明文保存在文件里，即使用完就会删除，但是这个时间间隙被利用就相当危险了。</p>

<blockquote>
  <p><strong>注</strong> 文章首次发表在团队博客<a href="http://mysql.taobao.org/monthly/2018/04/01/">数据内核月报201804期</a></p>
</blockquote>



                <hr style="visibility: hidden;">

                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/computer%20science/database/2018/02/06/performance-schema-acl/" data-toggle="tooltip" data-placement="top" title="MySQL 权限浅析">
                        Previous<br>
                        <span>MySQL 权限浅析</span>
                        </a>
                    </li>
                    
                    
                    <li class="next">
                        <a href="/computer%20science/database/mysql/2018/05/20/online-DDL/" data-toggle="tooltip" data-placement="top" title="Online DDL 工具 gh-ost 支持阿里云 RDS">
                        Next<br>
                        <span>Online DDL 工具 gh-ost 支持阿里云 RDS</span>
                        </a>
                    </li>
                    
                </ul>


                
                <!-- disqus 评论框 start -->
                <div class="comment">
                    <div id="disqus_thread" class="disqus-thread"></div>
                </div>
                <!-- disqus 评论框 end -->
                

                
            </div>  

    <!-- Side Catalog Container -->
        

    <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <hr class="hidden-sm hidden-xs">
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
        				
                            
                				<a href="/tags/#c++" title="c++" rel="6">
                                    c++
                                </a>
                            
        				
                            
        				
                            
        				
                            
        				
                            
                				<a href="/tags/#effective c++" title="effective c++" rel="2">
                                    effective c++
                                </a>
                            
        				
                            
        				
                            
                				<a href="/tags/#Berkeley DB" title="Berkeley DB" rel="6">
                                    Berkeley DB
                                </a>
                            
        				
                            
                				<a href="/tags/#Database" title="Database" rel="7">
                                    Database
                                </a>
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
                				<a href="/tags/#设计原则" title="设计原则" rel="2">
                                    设计原则
                                </a>
                            
        				
                            
                				<a href="/tags/#面向对象" title="面向对象" rel="4">
                                    面向对象
                                </a>
                            
        				
                            
        				
                            
                				<a href="/tags/#PostgreSQL" title="PostgreSQL" rel="4">
                                    PostgreSQL
                                </a>
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
        			</div>
                </section>
                

                <!-- Friends Blog -->
                
                <hr>
                <h5>FRIENDS</h5>
                <ul class="list-inline">
                    
                        <li><a href="http://blog.csdn.net/michaelyang_yz">Michael Yang</a></li>
                    
                        <li><a href="http://mysql.taobao.org/monthly/">数据库内核月报</a></li>
                    
                        <li><a href="https://www.percona.com/blog/">percona</a></li>
                    
                        <li><a href="http://dinglin.iteye.com/">丁奇</a></li>
                    
                        <li><a href="http://yoshinorimatsunobu.blogspot.com/">YOSHINORI MATSUNOBU'S BLOG</a></li>
                    
                        <li><a href="https://coolshell.cn/">酷壳</a></li>
                    
                        <li><a href="http://www.pagefault.info/">Pagefault</a></li>
                    
                        <li><a href="http://hedengcheng.com/">何登成</a></li>
                    
                        <li><a href="https://planet.mysql.com/">planet mysql</a></li>
                    
                        <li><a href="http://mysqlserverteam.com/">mysqlserver team</a></li>
                    
                        <li><a href="http://mysqlmusings.blogspot.com/">mysqlmusings</a></li>
                    
                        <li><a href="http://lefred.be/">lefred</a></li>
                    
                </ul>
                
            </div>
        </div>
    </div>
</article>






<!-- disqus 公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES * * */
    var disqus_shortname = "zhangxiaojian";
    var disqus_identifier = "/computer%20science/database/mysql/2018/04/18/innodb Encryption";
    var disqus_url = "http://localhost:4000/computer%20science/database/mysql/2018/04/18/innodb-Encryption/";

    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<!-- disqus 公共JS代码 end -->




<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("//cdnjs.cloudflare.com/ajax/libs/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'always',
          placement: 'right',
          icon: '#'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>


    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    
                    

                    <!-- add Weibo, Zhihu by Hux, add target = "_blank" to <a> by Hux -->
                    
                    <li>
                        <a target="_blank" href="https://www.zhihu.com/people/zhang-xiao-jian-49">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa  fa-stack-1x fa-inverse">知</i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li>
                        <a target="_blank" href="http://weibo.com/zhangxiaojianjj">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-weibo fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    


                    
                    
                    <li>
                        <a target="_blank" href="https://github.com/zhangxiaojian">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; 张小贱 2018
                    <br>
                </p>
            </div>
       </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js "></script>

<!-- Bootstrap Core JavaScript -->
<!-- Currently, only navbar scroll-down effect at desktop still depends on this -->
<script src="/js/bootstrap.min.js "></script>

<!-- Custom Theme JavaScript -->
<script src="/js/hux-blog.min.js "></script>

<!-- Service Worker -->

<script src="/js/snackbar.js "></script>
<script src="/js/sw-registration.js "></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!--
     Because of the native support for backtick-style fenced code blocks
     right within the Markdown is landed in Github Pages,
     From V1.6, There is no need for Highlight.js,
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/
     - https://github.com/jneen/rouge/wiki/list-of-supported-languages-and-lexers
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async('/js/jquery.tagcloud.js',function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->

<script>
    // dynamic User by Hux
    var _gaId = 'UA-112459552-1';
    var _gaDomain = '';

    // Originial
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', _gaId, _gaDomain);
    ga('send', 'pageview');
</script>



<!-- Baidu Tongji -->



<!-- Side Catalog -->



<!-- Multi-Lingual -->




<!-- Image to hack wechat -->
<img src="/img/icon_wechat.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work -->

</body>

</html>
