<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="life test">
    <meta name="keywords"  content="mysql">
    <meta name="theme-color" content="#000000">

    <title>MySQL · 引擎特性 · IO_CACHE 源码解析 - 张小贱的博客 | Zhangxiaojian Blog</title>

    <!-- Web App Manifest -->
    <link rel="manifest" href="/pwa/manifest.json">

    <!-- Favicon -->
    <link rel="shortcut icon" href="/img/favicon.ico">
    
    <!-- Canonical URL -->
    <link rel="canonical" href="http://localhost:4000/computer%20science/database/mysql/2018/09/20/binlog/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/hux-blog.min.css">

    <!-- Pygments Github CSS -->
    <link rel="stylesheet" href="/css/syntax.css">

    <!-- Custom Fonts -->
    <!-- <link href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- Hux Delete, sad but pending in China
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
    css'>
    -->


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">

    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">张小贱</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>
                    
                    <li>
                        <a href="/about/">About</a>
                    </li>
                    
                    <li>
                        <a href="/tags/">Tags</a>
                    </li>
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>

<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    var __HuxNav__ = {
        close: function(){
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        },
        open: function(){
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }

    // Bind Event
    $toggle.addEventListener('click', function(e){
        if ($navbar.className.indexOf('in') > 0) {
            __HuxNav__.close()
        }else{
            __HuxNav__.open()
        }
    })

    /**
     * Since Fastclick is used to delegate 'touchstart' globally
     * to hack 300ms delay in iOS by performing a fake 'click',
     * Using 'e.stopPropagation' to stop 'touchstart' event from 
     * $toggle/$collapse will break global delegation.
     * 
     * Instead, we use a 'e.target' filter to prevent handler
     * added to document close HuxNav.  
     *
     * Also, we use 'click' instead of 'touchstart' as compromise
     */
    document.addEventListener('click', function(e){
        if(e.target == $toggle) return;
        if(e.target.className == 'icon-bar') return;
        __HuxNav__.close();
    })
</script>


    <!-- Image to hack wechat -->
<!-- <img src="/img/icon_wechat.png" width="0" height="0"> -->
<!-- <img src="/img/home-bg-o.jpg" width="0" height="0"> -->

<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        position: relative;
        background-image: url('/img/home-bg-o.jpg')
    }

    
</style>
<header class="intro-header" >
    <div class="header-mask"></div>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        
                    </div>
                    <h1>MySQL · 引擎特性 · IO_CACHE 源码解析</h1>
                    
                    
                    <h2 class="subheading"></h2>
                    
                    <span class="meta">Posted by zhangxiaojian on September 20, 2018</span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

    <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <!-- Multi-Lingual -->
                

				<h2 id="概述">概述</h2>
<p>在数据库中 IO 的重要性不言而喻，为了更好的管理 IO 操作，大多数数据库都自己管理页数据和刷脏机制（例如 InnoDB 中的 Buffer pool），而不是交给文件系统甚至是操作系统调度。但是对于顺序写入的日志数据，使用文件系统接口方便的多，<a href="https://gcallah.github.io/OperatingSystems/FileImplementation.html">文件系统</a> 也是以页的形式管理，呈现给应用层的是一片连续可写的空间，管理的单位称为 Sector 大小是 4KB，所以对于 4KB 对齐的地址读写可以避免跨多个 Sector，对文件系统的性能有很大的提高。MySQL 中的 IO_CACHE 的作用就是把连续的文件读写操作，经过缓冲，转化为 4K 对齐的文件读写操作。</p>

<p><img src="http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/22fe36946aa263cfecfb5ba3743be443.png" alt="0920-iocache1.png" /></p>

<p>如图所示，对于文件的读写操作如果小于 IO_CACHE 大小，就放到缓冲中，当 IO_CACHE 满了就进行一次 4KB 对齐的写入，如果一次读写超过 IO_CACHE 的大小，就把 4K 对齐的数据进行一次读写，剩余部分放到 IO_CACHE 中，等待下次读写一起合并。</p>

<h2 id="源码解析">源码解析</h2>
<p>IO_CACHE 有不同的类型，定义在 cache_type 中：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>enum cache_type
{
  TYPE_NOT_SET= 0, READ_CACHE, WRITE_CACHE,
  SEQ_READ_APPEND		/* sequential read or append */,
  READ_FIFO, READ_NET,WRITE_NET};
</code></pre></div></div>
<p>常用的 general log, slow log, err log, binlog 主要使用 READ_CACHE, WRITE_CACHE, SEQ_READ_APPEND 几种类型，本文主要介绍这几种。同时 IO_CACHE 也提供支持 AIO 的接口，支持多线程同时访问 IO_CACHE 等，目前来看来应用也不多，暂不涉及。</p>

<p>主要代码在 mysys/mf_iocache.c 中，</p>

<p>READ_CACHE 是读缓冲，WRITE_CACHE 是写缓冲，SEQ_READ_APPEND 同时支持读写，写线程不断 append 数据到文件尾，读线程去 read 数据。append 使用 IO_CACHE::write_buffer, read 使用 IO_CACHE::buffer。当读到 write_buffer 中的数据时，就从 write_buffer 中拿数据。SEQ_READ_APPEND 这种类型在 MySQL 复制模块使用，IO 线程负责 append 数据到 relay log，SQL 线程负责 read 出来应用（考虑下为什么在主库上的写入线程和 Dump 线程之间不是使用这种方法，而是简单的 read-write，因为主库上 order_commit 函数很可能成为性能的瓶颈，和 Dump 线程竞争 append_buffer_lock 似乎并不好），因为 SEQ_READ_APPEND 类型更具有代表性，就以这种类型为例介绍。</p>

<h3 id="基础数据结构">基础数据结构</h3>
<p>基本的结构是 IO_CACHE，代码中注释写的比较清楚，这里贴一下方便后面看，</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>typedef struct st_io_cache
{
  /* Offset in file corresponding to the first byte of uchar* buffer. */
  my_off_t pos_in_file;
  /*
    The offset of end of file for READ_CACHE and WRITE_CACHE.
    For SEQ_READ_APPEND it the maximum of the actual end of file and
    the position represented by read_end.
  */
  my_off_t end_of_file;
  /* Points to current read position in the buffer */
  uchar	*read_pos;
  /* the non-inclusive boundary in the buffer for the currently valid read */
  uchar  *read_end;
  uchar  *buffer;				/* The read buffer */
  /* Used in ASYNC_IO */
  uchar  *request_pos;

  /* Only used in WRITE caches and in SEQ_READ_APPEND to buffer writes */
  uchar  *write_buffer;
  /*
    Only used in SEQ_READ_APPEND, and points to the current read position
    in the write buffer. Note that reads in SEQ_READ_APPEND caches can
    happen from both read buffer (uchar* buffer) and write buffer
    (uchar* write_buffer).
  */
  uchar *append_read_pos;
  /* Points to current write position in the write buffer */
  uchar *write_pos;
  /* The non-inclusive boundary of the valid write area */
  uchar *write_end;

  /*
    Current_pos and current_end are convenience variables used by
    my_b_tell() and other routines that need to know the current offset
    current_pos points to &amp;write_pos, and current_end to &amp;write_end in a
    WRITE_CACHE, and &amp;read_pos and &amp;read_end respectively otherwise
  */
  uchar  **current_pos, **current_end;

  /*
    The lock is for append buffer used in SEQ_READ_APPEND cache
    need mutex copying from append buffer to read buffer.
  */
  mysql_mutex_t append_buffer_lock;

  /*
    A caller will use my_b_read() macro to read from the cache
    if the data is already in cache, it will be simply copied with
    memcpy() and internal variables will be accordinging updated with
    no functions invoked. However, if the data is not fully in the cache,
    my_b_read() will call read_function to fetch the data. read_function
    must never be invoked directly.
  */
  int (*read_function)(struct st_io_cache *,uchar *,size_t);
  /*
    Same idea as in the case of read_function, except my_b_write() needs to
    be replaced with my_b_append() for a SEQ_READ_APPEND cache
  */
  int (*write_function)(struct st_io_cache *,const uchar *,size_t);
  /*
    Specifies the type of the cache. 
  */
  enum cache_type type;
  /*
    Callbacks when the actual read I/O happens. These were added and
    are currently used for binary logging of LOAD DATA INFILE - when a
    block is read from the file, we create a block create/append event, and
    when IO_CACHE is closed, we create an end event. These functions could,
    of course be used for other things
  */
  IO_CACHE_CALLBACK pre_read;
  IO_CACHE_CALLBACK post_read;
  IO_CACHE_CALLBACK pre_close;
  /*
    Counts the number of times, when we were forced to use disk. We use it to
    increase the binlog_cache_disk_use and binlog_stmt_cache_disk_use status
    variables.
  */
  ulong disk_writes;
  void* arg;				/* for use by pre/post_read */
  char *file_name;			/* if used with 'open_cached_file' */
  char *dir,*prefix;
  File file; /* file descriptor */
  /*
    seek_not_done is set by my_b_seek() to inform the upcoming read/write
    operation that a seek needs to be preformed prior to the actual I/O
    error is 0 if the cache operation was successful, -1 if there was a
    "hard" error, and the actual number of I/O-ed bytes if the read/write was
    partial.
  */
  int	seek_not_done,error;
  /* buffer_length is memory size allocated for buffer or write_buffer */
  size_t	buffer_length;
  /* read_length is the same as buffer_length except when we use async io */
  size_t  read_length;
  myf	myflags;			/* Flags used to my_read/my_write */
  /*
    alloced_buffer is 1 if the buffer was allocated by init_io_cache() and
    0 if it was supplied by the user.
    Currently READ_NET is the only one that will use a buffer allocated
    somewhere else
  */
  my_bool alloced_buffer;
} IO_CACHE;
</code></pre></div></div>

<h3 id="初始化">初始化</h3>
<p>初始化函数是 init_io_cache ，主要会做以下几件事：</p>

<ol>
  <li>和对应的文件描述符绑定，初始化 IO_CACHE 中各种变量。</li>
  <li>分配 write_buffer 和 read_buffer 的空间。</li>
  <li>初始化互斥变量 append_buffer_lock. (对于 SEQ_READ_APPEND 类型而言)</li>
  <li>init_functions 初始化对应的文件读写函数。</li>
</ol>

<p>其中根据传入的参数 cache_size 分配缓冲空间，一般传入的空间都不算大，例如 Binlog 的 IO_CACHE 初始化传入的大小就是 IO_SIZE（4KB），因为文件系统本身是有 page cache 的，只有调用 fsync 操作才会保证数据落盘，所以 IO_CACHE 就没必要缓冲太多的数据，只做把数据对齐写入的活。但并不是传进来多大空间就分配多大空间，看下代码：</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">min_cache</span><span class="o">=</span><span class="n">use_async_io</span> <span class="o">?</span> <span class="n">IO_SIZE</span><span class="o">*</span><span class="mi">4</span> <span class="o">:</span> <span class="n">IO_SIZE</span><span class="o">*</span><span class="mi">2</span><span class="p">;</span>

<span class="n">cachesize</span><span class="o">=</span> <span class="p">((</span><span class="n">cachesize</span> <span class="o">+</span> <span class="n">min_cache</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">min_cache</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>
<span class="k">for</span> <span class="p">(;;)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cachesize</span> <span class="o">&lt;</span> <span class="n">min_cache</span><span class="p">)</span>
		<span class="n">cachesize</span> <span class="o">=</span> <span class="n">min_cache</span><span class="p">;</span>
   <span class="n">buffer_block</span><span class="o">=</span> <span class="n">cachesize</span><span class="p">;</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">SEQ_READ_APPEND</span><span class="p">)</span>
		<span class="n">buffer_block</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
	
	<span class="k">if</span> <span class="p">((</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="o">=</span> <span class="p">(</span><span class="n">uchar</span><span class="o">*</span><span class="p">)</span> <span class="n">my_malloc</span><span class="p">(</span><span class="n">buffer_block</span><span class="p">,</span> <span class="n">flags</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
   <span class="p">{</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">write_buffer</span><span class="o">=</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">SEQ_READ_APPEND</span><span class="p">)</span>
	  		<span class="n">info</span><span class="o">-&gt;</span><span class="n">write_buffer</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">buffer</span> <span class="o">+</span> <span class="n">cachesize</span><span class="p">;</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">alloced_buffer</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>					<span class="cm">/* Enough memory found */</span>
   <span class="p">}</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">cachesize</span> <span class="o">==</span> <span class="n">min_cache</span><span class="p">)</span>
		<span class="n">DBUG_RETURN</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>				<span class="cm">/* Can't alloc cache */</span>
   <span class="cm">/* Try with less memory */</span>
      <span class="n">cachesize</span><span class="o">=</span> <span class="p">(</span><span class="n">cachesize</span><span class="o">*</span><span class="mi">3</span><span class="o">/</span><span class="mi">4</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">min_cache</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>
<span class="p">}</span>    
</code></pre></div></div>
<p>最小的分配空间在不使用 AIO 的情况下是 8K，这个后面会用到，SEQ_READ_APPEND 类型会分配两倍空间，因为有读缓冲和写缓冲。如果申请的空间无法满足就试图申请小一点的空间。</p>

<p>init_functions 是根据 IO_CACHE 的类型初始化 IO_CACHE::read_function 和 IO_CACHE::write_function，当缓冲大小没法满足文件 IO 请求的时候就会调用这两个函数去文件中交换数据。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">case</span> <span class="n">SEQ_READ_APPEND</span><span class="p">:</span>
    <span class="n">info</span><span class="o">-&gt;</span><span class="n">read_function</span> <span class="o">=</span> <span class="n">_my_b_seq_read</span><span class="p">;</span>
    <span class="n">info</span><span class="o">-&gt;</span><span class="n">write_function</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>			<span class="cm">/* Force a core if used */</span>
    <span class="k">break</span><span class="p">;</span>
<span class="k">default</span><span class="o">:</span>
    <span class="n">info</span><span class="o">-&gt;</span><span class="n">read_function</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">share</span> <span class="o">?</span> <span class="n">_my_b_read_r</span> <span class="o">:</span> <span class="n">_my_b_read</span><span class="p">;</span>
    <span class="n">info</span><span class="o">-&gt;</span><span class="n">write_function</span> <span class="o">=</span> <span class="n">_my_b_write</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div></div>
<p>SEQ_READ_APPEND 的写直接调用 my_b_append。</p>

<h3 id="调用接口">调用接口</h3>
<p>主要的接口在 include/my_sys.h 文件中，大多是宏定义形式。简单看几个常用的：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define my_b_read(info,Buffer,Count) \
  ((info)-&gt;read_pos + (Count) &lt;= (info)-&gt;read_end ?\
   (memcpy(Buffer,(info)-&gt;read_pos,(size_t) (Count)), \
    ((info)-&gt;read_pos+=(Count)),0) :\
   (*(info)-&gt;read_function)((info),Buffer,Count))
</span></code></pre></div></div>
<p>从 IO_CACHE info 中读取 Count 个字节到 Buffer 中，read_pos 是当前读到的位置，相对于 IO_CACHE::buffer，read_end 是缓冲区的末尾，这要要注意的是 read_end 相对于 IO_CACHE::buffer 的长度，并不一定是缓冲的长度，因为在读写过程中会调整缓冲区大小做 4K 对齐。逻辑比较简单，如果缓冲区的有效数据长度不够，那么就调用 read_function 做文件 IO。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define my_b_write(info,Buffer,Count) \
 ((info)-&gt;write_pos + (Count) &lt;=(info)-&gt;write_end ?\
  (memcpy((info)-&gt;write_pos, (Buffer), (size_t)(Count)),\
   ((info)-&gt;write_pos+=(Count)),0) : \
   (*(info)-&gt;write_function)((info),(uchar *)(Buffer),(Count)))
</span></code></pre></div></div>
<p>从 Buffer 中向 IO_CACHE info 写 Count 个字节数据，逻辑类似，如果写入缓冲不够，就做一次文件 IO。</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#define my_b_tell(info) ((info)-&gt;pos_in_file + \
			 (size_t) (*(info)-&gt;current_pos - (info)-&gt;request_pos))
</code></pre></div></div>
<p>这里 request_pos 是指向 IO_CACHE::buffer 的，而 current_pos 在 setup_io_cache 中初始化为 read_pos 或者 write_pos, 这种设计就可以为不同的 cache type 提供统一的接口。</p>

<p>还有一些非宏定义的接口比如 my_b_seek 等在文件 mysys_iocache2.c 中，不一一介绍，总之文件系统常用的操作在 IO_CACHE 中基本都可以找到。</p>

<h3 id="_my_b_seq_read">_my_b_seq_read</h3>
<p>以 SEQ_READ_APPEND 类型为例，文件 IO 的函数是 _my_b_seq_read, 整个流程分为三个阶段：</p>

<ol>
  <li>read from info-&gt;buffer</li>
  <li>read from file description</li>
  <li>try append buffer</li>
</ol>

<p>因为 SEQ_READ_APPEND 类型的读可能会读到 info-&gt;write_buffer 中还没来及写到文件系统里的数据，所以第三步就是去写缓冲中读。整个代码的精髓在于计算需要读多少数据才能保证对齐，看下代码:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 先把 IO_CACHE 里剩下的数据读到 Buffer 里</span>
<span class="k">if</span> <span class="p">((</span><span class="n">left_length</span><span class="o">=</span><span class="p">(</span><span class="kt">size_t</span><span class="p">)</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">read_end</span><span class="o">-</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">read_pos</span><span class="p">))</span>
<span class="p">{</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">Buffer</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">read_pos</span><span class="p">,</span> <span class="n">left_length</span><span class="p">);</span>
    <span class="n">Buffer</span><span class="o">+=</span><span class="n">left_length</span><span class="p">;</span>
    <span class="n">Count</span><span class="o">-=</span><span class="n">left_length</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">//更新 pos_in_file, 如果更新之后超出了 end_of_file, 就去 append_buffer 中读取。</span>
<span class="k">if</span> <span class="p">(</span><span class="n">pos_in_file</span><span class="o">=</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">pos_in_file</span> <span class="o">+</span>
    <span class="p">(</span><span class="kt">size_t</span><span class="p">)(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">read_end</span> <span class="o">-</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">buffer</span><span class="p">))</span> <span class="o">&gt;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">end_of_file</span><span class="p">)</span>
    <span class="k">goto</span> <span class="n">read_append_buffer</span><span class="p">;</span>

<span class="c1">// diff_length 为了对齐读</span>
<span class="n">diff_length</span><span class="o">=</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)(</span><span class="n">pos_in_file</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">IO_SIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">));</span>

<span class="c1">// 第二阶段，从文件里读数据</span>
<span class="c1">// 一般 IO_CACHE 默认初始化是 2*IO_CACHE，8KB，这个意思是 Count 的大小已经不能放在一个 IO_CACHE</span>
<span class="c1">// 的 Buffer 里</span>
<span class="k">if</span> <span class="p">(</span><span class="n">Count</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)(</span><span class="n">IO_SIZE</span> <span class="o">+</span> <span class="p">(</span><span class="n">IO_SIZE</span> <span class="o">-</span> <span class="n">diff_length</span><span class="p">)</span>
<span class="p">{</span>
 <span class="err"> </span> <span class="err"> </span><span class="c1">// 到这里面说明 Count 要读的数据超过了 IO_CACHE 中的 Buffer 大小，直接读到 Buffer</span>
    <span class="c1">// 那么读多少比较合适呢？</span>
<span class="c1">// 取出高阶的 IO_CACHE，整数个。(Count &amp; (size_t)~(IO_SIZAE-1))</span>
<span class="c1">// 但是因为 pos_in_file 相对于 4K 对齐地址还有一定的偏移量，再减去这个偏移，保证整个读取是对齐的</span>
    <span class="n">length</span><span class="o">=</span><span class="p">(</span><span class="n">Count</span> <span class="o">&amp;</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="o">~</span><span class="p">(</span><span class="n">IO_SIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">-</span><span class="n">diff_Lenght</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">read_length</span><span class="o">=</span><span class="n">mysql_file_read</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">,</span> <span class="n">Buffer</span><span class="p">,</span> <span class="n">length</span><span class="p">..){}</span>
    <span class="c1">// update after read</span>
    <span class="n">Count</span> <span class="o">-=</span> <span class="n">read_lenght</span><span class="p">;</span>
    <span class="n">Buffer</span> <span class="o">+=</span> <span class="n">read_leagth</span><span class="p">;</span>
    <span class="n">pos_in_file</span> <span class="o">+=</span> <span class="n">read_length</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">read_length</span> <span class="o">!=</span> <span class="n">length</span><span class="p">)</span>
        <span class="k">goto</span> <span class="n">read_append_buffer</span><span class="p">;</span> <span class="c1">// 没有读到想要的长度</span>
    <span class="n">left_length</span> <span class="o">+=</span> <span class="n">length</span><span class="p">;</span>
    <span class="n">diff_length</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>  <span class="c1">// no diff length now</span>
<span class="p">}</span>

<span class="c1">// IO_CACHE buffer 中还可以读多少数据。</span>
<span class="n">max_length</span><span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">read_length</span><span class="o">-</span><span class="n">diff_length</span><span class="p">;</span>
<span class="c1">// 可能会超出文件结尾，需要到 append buffer 读取</span>
<span class="k">if</span> <span class="p">(</span><span class="n">max_length</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">end_of_file</span> <span class="o">-</span> <span class="n">pos_in_file</span><span class="p">)</span>
    <span class="n">max_length</span><span class="o">=</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">end_of_file</span> <span class="o">-</span> <span class="n">pos_in_file</span><span class="p">)</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">max_length</span><span class="p">)</span> <span class="c1">// 已经到了文件尾</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Count</span><span class="p">)</span> <span class="c1">// 如果还有东西要读</span>
        <span class="k">goto</span> <span class="n">read_append_buffer</span><span class="p">;</span> <span class="err">去</span> <span class="n">append</span> <span class="n">buffer</span> <span class="err">读</span>
<span class="p">}</span><span class="k">else</span> <span class="c1">// 还可以读一些东西</span>
<span class="p">{</span>
    <span class="c1">// 读到 info-&gt;buffer 里，max_length 要么读到真实文件尾，要么读到 read buffer的尽头</span>
    <span class="n">length</span><span class="o">=</span> <span class="n">mysql_file_read</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">bufffer</span><span class="p">,</span> <span class="n">max_length</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">lenth</span> <span class="o">&lt;</span> <span class="n">Count</span><span class="p">)</span> <span class="err">还有东西要读</span>
    <span class="p">{</span>
        <span class="k">goto</span> <span class="n">read_append_buffer</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>     

<span class="k">return</span> <span class="mi">0</span><span class="err">；</span>

<span class="n">read_append_buffer</span><span class="o">:</span>
<span class="p">{</span>
    <span class="c1">// 先看 append buffer 剩余多少空间</span>
    <span class="kt">size_t</span> <span class="n">len_in_buffer</span> <span class="o">=</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">write_pos</span> <span class="o">-</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">append_read_pos</span><span class="p">);</span>
    <span class="c1">// 取其精华</span>
    <span class="n">copy_len</span><span class="o">=</span> <span class="n">MY_MIN</span><span class="p">(</span><span class="n">Count</span><span class="p">,</span> <span class="n">len_in_buffer</span><span class="p">);</span>
    <span class="n">memcpy</span> <span class="err">到</span> <span class="n">BUffer</span>
    <span class="cm">/* Fill read buffer with data from wirte buffer*/</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="my_b_flush_io_cache">my_b_flush_io_cache</h3>
<p>介绍写之前先介绍下这个函数，它的作用就是把 write_buffer 中数据写到文件系统里，在 IO_CACHE 的操作用这个函数才会真正发生不对齐的 IO，因为要写入的数据已经都在这了，最后的长度谁也没法保证对齐，IO_CACHE 并不会填充一些无意义的数据进去。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">((</span><span class="n">length</span><span class="o">=</span><span class="p">(</span><span class="kt">size_t</span><span class="p">)(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">write_pos</span> <span class="o">-</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">write_buffer</span><span class="p">)))</span>
<span class="p">{</span><span class="c1">// length 是写缓冲区中数据的长度</span>
    <span class="n">pos_in_file</span><span class="o">=</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">pos_in_file</span><span class="p">;</span>    <span class="c1">// 保存一下，后面有用</span>
    <span class="p">...</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">append_cache</span><span class="p">)</span>
        <span class="n">info</span><span class="o">-&gt;</span><span class="n">pos_in_file</span> <span class="o">+=</span> <span class="n">length</span><span class="p">;</span>
    <span class="c1">// 这一步是 write_cache 的精华，获得总的 buffer 大小，然后减去当前文件 pos + length </span>
    <span class="c1">// 之和，剩余部分就是文件中还没有对齐的地方，下一个写入这么大的数据，就可以满足一次对齐写</span>
    <span class="c1">// 所以当 buffer 比较小的时候，为了满足这种对齐的要求，可使用的 buffer 就会比较小，</span>
	<span class="c1">// 从而触发更多的文件 IO 操作</span>
    <span class="n">info</span><span class="o">-&gt;</span><span class="n">write_end</span><span class="o">=</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">write_buffer</span> <span class="o">+</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">buffer_length</span> <span class="o">-</span> 
    <span class="p">(</span><span class="n">pos_in_file</span> <span class="o">+</span> <span class="n">length</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">IO_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)));</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">mysql_file_wirte</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">write_buffer</span><span class="err">，</span> <span class="n">length</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">myflags</span> <span class="o">|</span> 
        <span class="n">MY_NABP</span><span class="p">)</span>
        <span class="n">info</span><span class="o">-&gt;</span><span class="n">error</span><span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

    <span class="n">set_if_bigger</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">end_of_file</span><span class="p">,</span> <span class="p">(</span><span class="n">pos_in_file</span><span class="o">+</span><span class="n">length</span><span class="p">));</span>

    <span class="n">info</span><span class="o">-&gt;</span><span class="n">append_read_pos</span><span class="o">=</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">write_pos</span><span class="o">=</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">write_buffer</span><span class="p">;</span>

    <span class="p">....</span>
    
<span class="p">}</span>
</code></pre></div></div>

<h3 id="my_b_append">my_b_append</h3>
<p>相对于读，append 操作逻辑简单的多，和 _my_b_wirte 逻辑相似</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 和 _my_b_seq_read 互斥，保护 write buffer</span>
<span class="n">lock_append_buffer</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>

<span class="n">rest_length</span><span class="o">=</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">wirte_end</span> <span class="o">-</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">write_pos</span><span class="p">);</span>
<span class="c1">// 缓冲区够用</span>
<span class="k">if</span> <span class="p">(</span><span class="n">Count</span> <span class="o">&lt;=</span> <span class="n">rest_length</span><span class="p">)</span>
	<span class="k">goto</span> <span class="n">end</span><span class="p">;</span>
<span class="c1">// 缓冲区不够用，把剩下的空间写满	</span>
<span class="n">memcpy</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">write_pos</span><span class="p">,</span> <span class="n">Buffer</span><span class="p">,</span> <span class="n">reset_length</span><span class="p">);</span>
<span class="n">Buffer</span> <span class="o">+=</span> <span class="n">rest_length</span><span class="p">;</span>
<span class="n">Count</span> <span class="o">-=</span> <span class="n">rest_length</span><span class="p">;</span>
<span class="n">info</span><span class="o">-&gt;</span><span class="n">write_pos</span> <span class="o">+=</span> <span class="n">rest_length</span><span class="p">;</span>

<span class="c1">// 写满了，刷到文件系统里去</span>
<span class="k">if</span> <span class="p">(</span><span class="n">my_b_flush_io_cache</span><span class="p">)</span>
<span class="p">{</span>
	<span class="p">...</span>
<span class="p">}</span>
<span class="c1">// 如果要写入的太大，缓冲区可能放不下，要直接写到文件里去了。</span>
<span class="k">if</span> <span class="p">(</span><span class="n">Count</span> <span class="o">&gt;=</span> <span class="n">IO_SIZE</span><span class="p">)</span>
<span class="p">{</span>
	<span class="c1">// 写多少到文件里呢，IO_SIZE 以上对齐的部分。</span>
	<span class="n">length</span><span class="o">=</span> <span class="n">Count</span> <span class="o">&amp;</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="o">~</span><span class="p">(</span><span class="n">IO_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">mysql_file_write</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">,</span> <span class="n">Buffer</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="p">..);</span>
	
	<span class="n">Count</span><span class="o">-=</span><span class="n">length</span><span class="p">;</span>
	<span class="n">Buffer</span><span class="o">+=</span><span class="n">length</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">end_of_file</span><span class="o">+=</span><span class="n">length</span><span class="p">;</span>
	
<span class="p">}</span>

<span class="n">end</span><span class="o">:</span>
<span class="c1">// 到这里要么是缓冲区够用，要么是剩下的数据页足够放到缓冲区里</span>
<span class="n">memcpy</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">write_pos</span><span class="p">,</span> <span class="n">Buffer</span><span class="p">,</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">Count</span><span class="p">);</span>
<span class="n">info</span><span class="o">-&gt;</span><span class="n">write_pos</span> <span class="o">+=</span> <span class="n">Count</span><span class="p">;</span>
<span class="n">unlock_append_buffer</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></div></div>

<h2 id="总结">总结</h2>
<p>经过分析，IO_CACHE 是建立的文件系统之上的，把一系列顺序的 IO 操作经过缓冲，转化成 4K 对齐的 IO 操作落到文件系统中，因为文件系统的页缓冲，IO_CACHE 并不大，没有缓冲很多的数据。接口丰富，可以作为一个单独的组件提高文件系统的 IO 性能。</p>



                <hr style="visibility: hidden;">

                <ul class="pager">
                    
                    <li class="previous">
                        <a href="/computer%20science/database/mysql/2018/09/02/binlog/" data-toggle="tooltip" data-placement="top" title="MySQL · 引擎特性 · 主库 binlog 概览">
                        Previous<br>
                        <span>MySQL · 引擎特性 · 主库 binlog 概览</span>
                        </a>
                    </li>
                    
                    
                </ul>


                
                <!-- disqus 评论框 start -->
                <div class="comment">
                    <div id="disqus_thread" class="disqus-thread"></div>
                </div>
                <!-- disqus 评论框 end -->
                

                
            </div>  

    <!-- Side Catalog Container -->
        

    <!-- Sidebar Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <hr class="hidden-sm hidden-xs">
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
        				
                            
                				<a href="/tags/#c++" title="c++" rel="6">
                                    c++
                                </a>
                            
        				
                            
        				
                            
        				
                            
        				
                            
                				<a href="/tags/#effective c++" title="effective c++" rel="2">
                                    effective c++
                                </a>
                            
        				
                            
        				
                            
                				<a href="/tags/#Berkeley DB" title="Berkeley DB" rel="6">
                                    Berkeley DB
                                </a>
                            
        				
                            
                				<a href="/tags/#Database" title="Database" rel="7">
                                    Database
                                </a>
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
                				<a href="/tags/#设计原则" title="设计原则" rel="2">
                                    设计原则
                                </a>
                            
        				
                            
                				<a href="/tags/#面向对象" title="面向对象" rel="4">
                                    面向对象
                                </a>
                            
        				
                            
        				
                            
                				<a href="/tags/#PostgreSQL" title="PostgreSQL" rel="4">
                                    PostgreSQL
                                </a>
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
                            
        				
        			</div>
                </section>
                

                <!-- Friends Blog -->
                
                <hr>
                <h5>FRIENDS</h5>
                <ul class="list-inline">
                    
                        <li><a href="http://blog.csdn.net/michaelyang_yz">Michael Yang</a></li>
                    
                        <li><a href="http://mysql.taobao.org/monthly/">数据库内核月报</a></li>
                    
                        <li><a href="https://www.percona.com/blog/">percona</a></li>
                    
                        <li><a href="http://dinglin.iteye.com/">丁奇</a></li>
                    
                        <li><a href="http://yoshinorimatsunobu.blogspot.com/">YOSHINORI MATSUNOBU'S BLOG</a></li>
                    
                        <li><a href="https://coolshell.cn/">酷壳</a></li>
                    
                        <li><a href="http://www.pagefault.info/">Pagefault</a></li>
                    
                        <li><a href="http://hedengcheng.com/">何登成</a></li>
                    
                        <li><a href="https://planet.mysql.com/">planet mysql</a></li>
                    
                        <li><a href="http://mysqlserverteam.com/">mysqlserver team</a></li>
                    
                        <li><a href="http://mysqlmusings.blogspot.com/">mysqlmusings</a></li>
                    
                        <li><a href="http://lefred.be/">lefred</a></li>
                    
                </ul>
                
            </div>
        </div>
    </div>
</article>






<!-- disqus 公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES * * */
    var disqus_shortname = "zhangxiaojian";
    var disqus_identifier = "/computer%20science/database/mysql/2018/09/20/binlog";
    var disqus_url = "http://localhost:4000/computer%20science/database/mysql/2018/09/20/binlog/";

    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<!-- disqus 公共JS代码 end -->




<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("//cdnjs.cloudflare.com/ajax/libs/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'always',
          placement: 'right',
          icon: '#'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>


    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    
                    

                    <!-- add Weibo, Zhihu by Hux, add target = "_blank" to <a> by Hux -->
                    
                    <li>
                        <a target="_blank" href="https://www.zhihu.com/people/zhang-xiao-jian-49">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa  fa-stack-1x fa-inverse">知</i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li>
                        <a target="_blank" href="http://weibo.com/zhangxiaojianjj">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-weibo fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    


                    
                    
                    <li>
                        <a target="_blank" href="https://github.com/zhangxiaojian">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; 张小贱 2018
                    <br>
                </p>
            </div>
       </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js "></script>

<!-- Bootstrap Core JavaScript -->
<!-- Currently, only navbar scroll-down effect at desktop still depends on this -->
<script src="/js/bootstrap.min.js "></script>

<!-- Custom Theme JavaScript -->
<script src="/js/hux-blog.min.js "></script>

<!-- Service Worker -->

<script src="/js/snackbar.js "></script>
<script src="/js/sw-registration.js "></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!--
     Because of the native support for backtick-style fenced code blocks
     right within the Markdown is landed in Github Pages,
     From V1.6, There is no need for Highlight.js,
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/
     - https://github.com/jneen/rouge/wiki/list-of-supported-languages-and-lexers
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async('/js/jquery.tagcloud.js',function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("//cdnjs.cloudflare.com/ajax/libs/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->

<script>
    // dynamic User by Hux
    var _gaId = 'UA-112459552-1';
    var _gaDomain = '';

    // Originial
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', _gaId, _gaDomain);
    ga('send', 'pageview');
</script>



<!-- Baidu Tongji -->



<!-- Side Catalog -->



<!-- Multi-Lingual -->




<!-- Image to hack wechat -->
<img src="/img/icon_wechat.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work -->

</body>

</html>
